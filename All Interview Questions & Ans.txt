It has Java Java 8 MultiThreading Spring boot RestApi Microservices Sql Interview Questions & Ans

Project : My Project Domain is Motor Insurance, client liberty general insurance india, the main purpose of the project is to provide the motor insurance in india motor insurance is mandatory for all vehicles so here a customer can approach us directly by our website or by dealer customer has to provide the vehicle details like make model engine chassis no and customer details with this we need to validate the request and tranform it asa per the other service request herewe need to make api calls to multiple third party api's like premium calculation and after successfully passing to service finally a policy copy with premium is generated and provided to customer

I'm seeking a job change to further develop my skills and take on new challenges. In my current role, I've gained significant experience working with Java Spring Boot, and now I'm looking for opportunities where I can continue to grow, contribute to larger-scale projects, and work with more advanced technologies. I'm also excited to join a team where I can collaborate, learn from others, and contribute to a more dynamic and innovative environment."

"I’m looking for new challenges where I can grow and apply my skills in a different environment. I believe your company offers the kind of opportunities I’m seeking

"Based on my research and experience in this field, I’m looking for a salary range between $X and $Y. However, I’m open to discussing this further based on the full compensation package and opportunities for growth."

CORE JAVA INTERVIEW QUESTIONS 10-Aug-24
1. JDK (Java Development Kit)
	What It Is: The JDK is a software development kit used to develop Java applications. It provides the tools needed to write, compile, debug, and run Java programs.
	Components: It includes the Java compiler (javac), the Java Runtime Environment (JRE), and various development tools like debuggers and profilers.
	Usage: Developers use the JDK to write and compile Java code. It's essential for development but not required for running already compiled Java programs.
	
2. JVM (Java Virtual Machine)
	What It Is: The JVM is an abstract machine that enables a computer to run Java programs. It is part of the JRE and is responsible for executing the Java bytecode (compiled Java programs).
	Components: It includes the execution engine, memory management (including garbage collection), and other components that help in running Java programs.
	Usage: When you run a Java program, the JVM interprets or compiles the bytecode into machine code appropriate for the operating system and hardware it is running on.
	
3. JRE (Java Runtime Environment)
	What It Is: The JRE is a package that provides the necessary environment for running Java applications. It includes the JVM and the core libraries that are required by Java applications.
	Components: It includes the JVM, core Java libraries, and other resources necessary for running Java applications.
	Usage: End-users install the JRE on their systems if they want to run Java applications. Developers use it for testing their applications.

4.Is java Purely object oriented
	Java is a strongly object-oriented language, but it is not purely object-oriented 
	because it includes features like primitive data types and static methods, which are not in line with pure object-oriented principles.

5.Explain PSVM in java?
	The public static void main(String[] args) method is the starting point for any Java application. It is where the program begins execution, and understanding it is essential for writing and running Java applications.
	public:
		Meaning: The public keyword indicates that the method is accessible from anywhere. It needs to be public so that the Java runtime can access it to start the application.
	static:
		Meaning: The static keyword means that the method belongs to the class rather than to any specific instance of the class. This allows the Java runtime to call the main method without having to create an instance of the class.
	void:
		Meaning: The void keyword indicates that the method does not return any value.
	main:
		Meaning: main is the name of the method that serves as the entry point of the application. When you run a Java program, the Java Virtual Machine (JVM) looks for this method to start execution.
	String[] args:
		Meaning: This is the parameter for the main method, which is an array of String objects. It allows the program to accept command-line arguments. args can contain the arguments passed to the program when it is started from the command line.
		
6.Explain OOPS
	Class and Object:
		Class: A class is a blueprint or template for creating objects. It defines the properties (attributes) and behaviors (methods) that the objects created from the class will have.
		Object: An object is an instance of a class. It is a concrete entity that contains data and behavior as defined by the class. For example, if you have a Car class, a specific car like "Honda Civic" would be an object of that class.
	Encapsulation:
		Definition: Encapsulation is the process of bundling data (attributes) and methods (functions) that operate on the data into a single unit, or class. It also involves restricting direct access to some of an object's components, which is typically achieved using access modifiers like private, protected, and public.
		Benefit: Encapsulation helps in protecting the internal state of an object from unintended or harmful interference and misuse.
	Inheritance:
		Definition: Inheritance allows a new class (subclass) to inherit attributes and methods from an existing class (superclass). This promotes code reuse and establishes a natural hierarchy between classes.
		Benefit: Inheritance helps in reducing redundancy, promoting code reusability, and making the code easier to maintain and extend.
	Polymorphism:
		Definition: Polymorphism means "many forms" and allows objects of different classes to be treated as objects of a common superclass. The two main types are:
		Compile-time polymorphism (Method Overloading): The ability to define multiple methods with the same name but different parameters.
		Runtime polymorphism (Method Overriding): The ability of a subclass to provide a specific implementation of a method that is already defined in its superclass.
		Benefit: Polymorphism allows for flexibility and the ability to define a common interface for different underlying data types, making the code more scalable and maintainable.
	Abstraction:
		Definition: Abstraction is the concept of hiding the complex implementation details and showing only the essential features of an object. In Java, abstraction is achieved using abstract classes and interfaces.
		Benefit: Abstraction reduces complexity by allowing the programmer to focus on interactions at a higher level rather than getting bogged down by details.
7.Explain Access Modifiers
	public: Visible to all classes everywhere.
	protected: Visible to classes in the same package and subclasses.
	default (no modifier): Visible only to classes within the same package.
	private: Visible only to the class in which it is declared.
	
8. What is Java String Pool?
	A Java String Pool is a place in heap memory where all the strings defined in the program are stored. A separate place in a stack is there where the variable storing the string is stored. Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.
	
9. What will happen if we declare don’t declare the main as static?
	We can declare the main method without using static and without getting any errors. But, the main method will not be treated as the entry point to the application or the program.
	
10 Data Types in JAVA ?
	Primitive Data Type: Primitive data are single values with no special capabilities. There are 8 primitive data types:
		boolean: stores value true or false
		byte: stores an 8-bit signed two’s complement integer
		char: stores a single 16-bit Unicode character
		short: stores a 16-bit signed two’s complement integer
		int: stores a 32-bit signed two’s complement integer
		long: stores a 64-bit two’s complement integer
		float: stores a single-precision 32-bit IEEE 754 floating-point
		double: stores a double-precision 64-bit IEEE 754 floating-point
	Non-Primitive Data Type: Reference Data types will contain a memory address of the variable’s values because it is not able to directly store the values in the memory. Types of Non-Primitive are mentioned below:
		Strings
		Array
		Class
		Object
		Interface
11.Instance variable & local variable?
	Instance variable	
		Declared outside the method, directly invoked by the method.
		Has a default value.
		Memory for instance variables is allocated when an object is created. 
		They are accessed using the object reference.
		It can be used throughout the class.
	local variable
		Declared within the method.                                                              
		No default value
		The scope is limited to the method.
	class variable
		In Java, a class variable (also known as a static variable) is a variable that is declared within a class but outside of any method, constructor, or block. 
		Memory for static variables is allocated when the class is loaded. There is only one copy of a static variable, shared among all instances of the class.
		Static variables are shared among all instances of a class. Changing the value of a static variable through one instance affects all other instances.
		Class variables are declared with the static keyword,
		
			public class Example {
				static int staticVar; // Static variable

				public Example(int value) {
					staticVar = value;
				}
			}

			public class Main {
				public static void main(String[] args) {
					Example obj1 = new Example(10);
					Example obj2 = new Example(20);

					System.out.println(Example.staticVar); // 20
					System.out.println(obj1.staticVar);    // 20
					System.out.println(obj2.staticVar);    // 20
				}
			}
		
12.InputStream & OutputStream
	// Writing binary data to a file using OutputStream
		byte[] data = {(byte) 0xe0, 0x4f, (byte) 0xd0, 0x20, (byte) 0xea};
		OutputStream os = new FileOutputStream("data.bin");
		os.write(data);
		os.close();

	// Reading binary data from a file using InputStream
		InputStream is = new FileInputStream("data.bin");
		byte[] newData = new byte[5];
	
	File file = new File("path_of_the_file");
	FileInputStream inputStream = new FileInputStream(file);

	File file = new File("path_of_the_file");
	FileOutputStream outputStream = new FileOutputStream(file);
	
	When we are working with the files or stream then to increase the Input/Output performance of the program we need to use the BufferedInputStream and BufferedOutputStream classes. 

13.What is the transient keyword?
	The transient keyword is used at the time of serialization if we don’t want to save the value of a particular variable in a file. When JVM comes across a transient keyword, it ignores the original value of the variable and saves the default value of that variable data type.
	
14 String StringBuffer, StringBuilder.
	String:
		Immutable.
		Thread-safe.
		Suitable for constant or fixed strings.
	StringBuffer:
		Mutable.
		Thread-safe (synchronized).
		Suitable for multiple modifications in a multi-threaded environment.
	StringBuilder:
		Mutable.
		Not thread-safe (not synchronized).
		Suitable for multiple modifications in a single-threaded environment for better performance

15. String vs new String	
	String Literal:
		Creation: String s = "Hello";
		Memory: Stored in the String Pool. Reuses existing literals with the same value.
		Performance: More memory-efficient due to reusability.
		Usage: Preferred for common or repeated string values.
	new String Object:
		Creation: String s = new String("Hello");
		Memory: Creates a new String object in the heap, separate from the String Pool.
		Performance: Less memory-efficient due to creating new objects.
		Usage: Used when you explicitly need a new String object and not just a reference to a pooled literal.
	s1.equals(s2) evaluates to true because the equals method compares the content of the strings.
	
16 Volatile keyword
	This keyword ensures that the value of the variable is always read from and written to the main memory, rather than being cached in a thread's local cache
	This can be crucial in concurrent programming to ensure that changes made to a variable by one thread are visible to other threads.
	
17 Diff way to create Object
	new Keyword: Commonly used for creating new objects with a constructor.
		MyClass obj = new MyClass();
	Clone: Create new objects by copying existing ones.
		MyClass obj2 = (MyClass) obj1.clone();
	Dependency Injection: Frameworks create and manage objects
			@Autowired
			MyClass obj;

18. Call by value vs reference in java(pass by value / pass by reference)
	Primitive Types: Passed by value, meaning the actual value is copied and used inside the method.
	
	public class Example {
		public static void main(String[] args) {
			int x = 10;
			modifyValue(x);
			System.out.println(x); // Prints 10
		}

		public static void modifyValue(int value) {
			value = 20;
		}
	}
	
	Object References: For objects, the reference (memory address) is passed , meaning the method receives a copy of the reference, but both the original and the copy refer to the same object.
	
	public class Example {
		public static void main(String[] args) {
			MyClass obj = new MyClass();
			obj.value = 10;
			modifyObject(obj);
			System.out.println(obj.value); // Prints 20
		}

		public static void modifyObject(MyClass obj) {
			obj.value = 20;
		}
	}
	
19 Constructor
	constructor is a special method used to initialize objects when they are created. 
	It has the same name as the class and does not have a return type. 
	Copy Constructor : 
	
		public class Car {
		String model;
		int year;

		// Default constructor
		public Car() {
			model = "Unknown";
			year = 0;
		}

		public static void main(String[] args) {
			Car myCar = new Car();
			System.out.println(myCar.model + " " + myCar.year); // Outputs: Unknown 0
		}
	}
20.Private Constructor 
	Purpose: Private constructors are used to control or prevent the instantiation of a class.
		Common Uses:
		Singleton Pattern: Ensures only one instance of a class.
		Utility Classes: Prevents instantiation and only provides static methods.
		Preventing Instantiation: For classes where instances should not be created
		
21.Singleton pattern
	Singleton Design Pattern:
	The Singleton pattern ensures that only one instance of a class is created. A private constructor is used to prevent direct instantiation of the class from outside its own code
	
	Purpose: To ensure that a class has only one instance and provides a global point of access to it.
	Use Cases: Configuration management, logging, database connections, thread pool management, caching.
	Variants: Eager Initialization, Lazy Initialization, Double-Checked Locking, Bill Pugh Singleton Design.
	
	public class Singleton {
	
    private static final Singleton instance = new Singleton();

    // Private constructor
			private Singleton() {
				// Initialization code
			}

			// Public method to provide access to the single instance
			public static Singleton getInstance() {
				return instance;
			}
		}

		public class Main {
			public static void main(String[] args) {
				Singleton singleton1 = Singleton.getInstance();
				Singleton singleton2 = Singleton.getInstance();

				System.out.println(singleton1 == singleton2); // Outputs: true
			}
		}
	
	Private Static Final Variable: Ensures that the instance is created only once and cannot be reassigned.
	Private Constructor: Prevents instantiation from other classes.
	Public Static Method: Provides a global point of access to the instance.

22. What is interface ?
	An interface is a blueprint of a class that can contain only abstract methods, default methods, static methods, and constants. 
	Purpose	
		Interfaces define a contract that implementing classes must adhere to.
		Support Multiple Inheritance
		Support Functional Programming: With functional interfaces, Java can leverage lambda expressions and method references, making code more concise and expressive.
	Fields
		Fields in an interface are implicitly public, static, and final (constants).
	methods
		All methods in an interface are implicitly public and abstract unless they are default or static.
		
		interface Animal {
			void makeSound(); // Abstract method

			default void breathe() {
				System.out.println("Breathing...");
			}

			static void sleep() {
				System.out.println("Sleeping...");
			}
		}

		class Dog implements Animal {
			@Override
			public void makeSound() {
				System.out.println("Bark");
			}
		}

		public class Main {
			public static void main(String[] args) {
				Dog dog = new Dog();
				dog.makeSound(); // Output: Bark
				dog.breathe();   // Output: Breathing...
				Animal.sleep();  // Output: Sleeping...
			}
		}
		
23.What is abstract class ?
	An abstract class in Java is a class that cannot be instantiated on its own and is meant to be subclassed. It can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation).
	
	Purpose:
		Abstract classes are used 
			when there is a common base class 
			provide a partial implementation 
			define abstract methods that must be implemented by subclasses.
	Fields
		No restriction public private protected
	Methods
		No restriction public private protected
		

	Abstract classes can have constructors just like regular classes. These constructors are used to initialize common state or perform setup tasks when a subclass object is created.
	Constructors in abstract classes are invoked when a subclass object is instantiated. 
	Abstract class constructors are not used to create instances of the abstract class directly, but they are called when creating an instance of a concrete subclass.
	
	Sure! Here are the answers to the 10 tricky questions related to abstract classes in Java, along with the code example you provided:

			### Tricky Questions on Abstract Classes

			1. **Can an abstract class have a constructor?**
			   - **Answer**: Yes, an abstract class can have a constructor. The constructor is called when an instance of a subclass is created.
			   ```java
			   abstract class Animal {
				   public Animal() {
					   System.out.println("Animal constructor called");
				   }
			   }

			   class Dog extends Animal {
				   public Dog() {
					   System.out.println("Dog constructor called");
				   }
			   }

			   public class Main {
				   public static void main(String[] args) {
					   Dog dog = new Dog(); // Output: Animal constructor called
											//         Dog constructor called
				   }
			   }
			   ```

			2. **Can an abstract class be final?**
			   - **Answer**: No, an abstract class cannot be declared as final. A final class cannot be subclassed, which contradicts the purpose of an abstract class.
			   ```java
			   // This will cause a compilation error
			   // final abstract class Animal {
			   // }

			   abstract class Animal {
				   public abstract void makeSound();
			   }
			   ```

			3. **Can an abstract class have static methods?**
			   - **Answer**: Yes, an abstract class can have static methods. However, these methods cannot be abstract because static methods belong to the class, not to instances.
			   ```java
			   abstract class Animal {
				   public static void staticMethod() {
					   System.out.println("Static method in abstract class");
				   }
			   }

			   public class Main {
				   public static void main(String[] args) {
					   Animal.staticMethod(); // Output: Static method in abstract class
				   }
			   }
			   ```

			4. **Can an abstract class implement an interface?**
			   - **Answer**: Yes, an abstract class can implement an interface. It can provide implementations for some or all of the interface methods. If it does not implement all methods, the subclass must implement the remaining methods.
			   ```java
			   interface Movable {
				   void move();
			   }

			   abstract class Animal implements Movable {
				   public void breathe() {
					   System.out.println("Breathing...");
				   }
			   }

			   class Dog extends Animal {
				   @Override
				   public void move() {
					   System.out.println("Dog is moving");
				   }
			   }

			   public class Main {
				   public static void main(String[] args) {
					   Dog dog = new Dog();
					   dog.move();    // Output: Dog is moving
					   dog.breathe(); // Output: Breathing...
				   }
			   }
			   ```

			5. **Can you declare an abstract method as private?**
			   - **Answer**: No, abstract methods cannot be private because they need to be accessible to subclasses for implementation.
			   ```java
			   abstract class Animal {
				   // This will cause a compilation error
				   // private abstract void makeSound();
			   }
			   ```

			6. **Can an abstract class have a main method?**
			   - **Answer**: Yes, an abstract class can have a main method. The main method can be used to run the program, but you cannot instantiate the abstract class directly.
			   ```java
			   abstract class Animal {
				   public static void main(String[] args) {
					   System.out.println("Main method in abstract class");
				   }
			   }
			   ```

			7. **What happens if a subclass does not implement all abstract methods of its superclass?**
			   - **Answer**: If a subclass does not implement all abstract methods of its abstract superclass, the subclass must also be declared as abstract.
			   ```java
			   abstract class Animal {
				   public abstract void makeSound();
			   }

			   abstract class Dog extends Animal {
				   // Dog does not implement makeSound(), so it must be abstract
			   }
			   ```

			8. **Can an abstract class extend another abstract class?**
			   - **Answer**: Yes, an abstract class can extend another abstract class. The subclass can inherit and implement abstract methods from the superclass.
			   ```java
			   abstract class Animal {
				   public abstract void makeSound();
			   }

			   abstract class Mammal extends Animal {
				   public void breathe() {
					   System.out.println("Breathing...");
				   }
			   }

			   class Dog extends Mammal {
				   @Override
				   public void makeSound() {
					   System.out.println("Bark");
				   }
			   }

			   public class Main {
				   public static void main(String[] args) {
					   Dog dog = new Dog();
					   dog.makeSound(); // Output: Bark
					   dog.breathe();   // Output: Breathing...
				   }
			   }
			   ```

			9. **Can an abstract class have instance variables?**
			   - **Answer**: Yes, an abstract class can have instance variables. These variables can be used by concrete methods within the abstract class or by subclasses.
			   ```java
			   abstract class Animal {
				   protected String name;

				   public Animal(String name) {
					   this.name = name;
				   }

				   public abstract void makeSound();
			   }

			   class Dog extends Animal {
				   public Dog(String name) {
					   super(name);
				   }

				   @Override
				   public void makeSound() {
					   System.out.println(name + " says: Bark");
				   }
			   }

			   public class Main {
				   public static void main(String[] args) {
					   Dog dog = new Dog("Buddy");
					   dog.makeSound(); // Output: Buddy says: Bark
				   }
			   }
			   ```

			10. **Can you create an array of abstract class type?**
				- **Answer**: Yes, you can create an array of an abstract class type. However, you cannot instantiate the abstract class itself, but you can store instances of its subclasses in the array.
				```java
				abstract class Animal {
					public abstract void makeSound();
				}

				class Dog extends Animal {
					@Override
					public void makeSound() {
						System.out.println("Bark");
					}
				}

				class Cat extends Animal {
					@Override
					public void makeSound() {
						System.out.println("Meow");
					}
				}

				public class Main {
					public static void main(String[] args) {
						Animal[] animals = new Animal[2];
						animals[0] = new Dog();
						animals[1] = new Cat();

						for (Animal animal : animals) {
							animal.makeSound(); // Output: Bark
												//         Meow
						}
					}
				}
				```

			### Code Example
			Here is the code example you provided, with the necessary changes to call the `breathe` method from the `Mammal` class after creating a `Dog` object:

			```java
			abstract class Animal {
				public abstract void makeSound();
			}

			abstract class Mammal extends Animal {
				public void breathe() {
					System.out.println("Breathing...");
				}
			}

			class Dog extends Mammal {
				@Override
				public void makeSound() {
					System.out.println("Bark");
				}
			}

			public class Main {
				public static void main(String[] args) {
					Dog dog = new Dog();
					dog.makeSound(); // Output: Bark

					// Cast the Dog object to Mammal and call the breathe method
					((Mammal) dog).breathe(); // Output: Breathing...
				}
			}


##. Abstract Class vs Interface
	Abstract Class
		Definition: A class that cannot be instantiated and is meant to be subclassed.
		Methods: Can have both abstract methods (without implementation) and concrete methods (with implementation).
		Fields: Can have instance variables with any access modifier (public, private, protected).
		Constructors: Can have constructors to initialize fields.
		Inheritance: A class can inherit from only one abstract class (single inheritance).
		Usage: Suitable for sharing code among closely related classes.
	Interface
		Definition: A reference type that can contain only constants, method signatures, default methods, static methods, and nested types.
		Methods: All methods are abstract by default (until Java 8, which introduced default and static methods).
		Fields: Can only have public static final variables (constants).
		Constructors: Cannot have constructors.
		Inheritance: A class can implement multiple interfaces (multiple inheritance).
		Usage: Ideal for defining a contract that multiple classes can implement, even if they are unrelated.

24.What is marker interface ? 
	In Java, a marker interface is an interface that contains no methods or fields and serves to indicate that a class implementing it possesses certain qualities or should be treated in a specific way by the Java runtime or other parts of the code.
	Marker interface is used to convey metadata about a class without actually specifying any methods that the class must implement.
	
	Serializable:
	Purpose: Indicates that a class can be serialized—converted into a byte stream and later deserialized (reconstructed from that byte stream).
		
		public interface Serializable {
		// No methods
		}

		public class MyClass implements Serializable {
			private int id;
			private String name;

			// Constructor, getters, setters, etc.
		}
	Serialization is the process of converting an object into a byte stream, which can then be saved to a file, sent over a network, or stored in a database.
	
	Cloneable:
	Purpose: Indicates that a class allows its objects to be cloned.
	Usage: If a class implements Cloneable, its clone() method is allowed to create a field-for-field copy of instances. If not implemented, calling clone() will throw a CloneNotSupportedException.
	
		public interface Cloneable {
		// No methods
		}

		public class MyClass implements Cloneable {
			private int id;
			private String name;

			@Override
			protected Object clone() throws CloneNotSupportedException {
				return super.clone();
			}
		}

25. Association, Aggregation, Composition,
	Association:
		Represents a general relationship between two objects.
		Can be bidirectional or unidirectional.
		Objects can have independent lifecycles.
		Ex ont to one, one to many, many to one
	Aggregation:
		Represents a whole-part relationship where the part can exist independently of the whole.
		Implies a weaker relationship than composition.
		Objects can be shared among different wholes.
		Ex Department and employee
	Composition:
		Represents a strong whole-part relationship where the part’s lifecycle is dependent on the whole.
		Implies a strong ownership and containment relationship.
		When the whole is destroyed, the parts are also destroyed.
		Room and house dependednt on each other if one is destroyed another also destroyed

26.Can we override the static method?
	No, as static methods are part of the class rather than the object so we can’t override them.

27.Can we override the overloaded method?
	Yes, since the overloaded method is a completely different method in the eyes of the compiler. Overriding isn’t the same thing at all. The decision as to which method to call is deferred to runtime.

28.Can we overload the main() method?
	Yes in Java we can overload the main method to call the main method with the help of its predefined calling method. 

29.Can the constructor be inherited?
	No, we can’t inherit a constructor.

30.Can we override the private methods?
	It is not possible to override the private methods in Java. Method overriding is where the method in the subclass is implemented instead of the method from the parent class. The private methods are accessible only within the class in which it is declared. Since this method is not visible to other classes and cannot be accessed, it cannot be overridden. 

31. Can we change the scope of the overridden method in the subclass?
	In Java, it is not possible to modify the overridden method’s scope. The subclass method’s scope must be equal to or wider than the Superclass method’s overridden method’s scope. The overridden method in the subclass, for instance, can have a public scope or a more accessible scope like protected or default if the overridden method in the superclass has a public scope. It cannot, however, have a more exclusive scope like private.

32. What is virtual functional
	 virtual function is a member function in a base class that you expect to override in derived classes.

33. How can you avoid serialization in the child class if the base class is implementing the Serializable interface?
	transient Keyword: Use transient to mark fields that should not be serialized. This is suitable when you only want to exclude certain fields from serialization.
	Custom Serialization: Override writeObject and readObject methods to control serialization and deserialization processes. This provides more fine-grained control over the serialization mechanism.

34.TRY CATCH THROWS
	try-catch Block
		Purpose: The try-catch block is used to handle exceptions that might occur within the code. 
		It allows you to catch exceptions when they are thrown and take appropriate action, such as logging the error, retrying the operation, or providing a fallback mechanism.
	throws Keyword	
		Purpose: The throws keyword is used in a method signature to indicate that the method might throw one or more exceptions. It doesn't handle the exceptions but instead propagates them up the call stack to be handled by the calling method.
		
35. Custom Exception
	Custom exceptions are useful when you want to create meaningful, application-specific error handling. By defining your own exceptions, you can make your code more readable and provide more detailed error messages specific to your application's domain.
		// Custom checked exception
		public class InsufficientFundsException extends Exception {

			// Default constructor
			public InsufficientFundsException() {
				super();
			}

			// Constructor that accepts a custom message
			public InsufficientFundsException(String message) {
				super(message);
			}

			// Constructor that accepts a custom message and a cause
			public InsufficientFundsException(String message, Throwable cause) {
				super(message, cause);
			}

			// Constructor that accepts a cause
			public InsufficientFundsException(Throwable cause) {
				super(cause);
			}
		}
		
		public class BankAccount {
			private double balance;

			public BankAccount(double balance) {
			this.balance = balance;
			}

			// Method to withdraw money
			public void withdraw(double amount) throws InsufficientFundsException {
			if (amount > balance) {
				throw new InsufficientFundsException("Insufficient funds. Balance available: " + balance);
			}
			balance -= amount;
			}

			public double getBalance() {
			return balance;
			}
		}


36.Try with resources
	The try-with-resources statement in Java provides a powerful and convenient way to manage resources that need to be closed after use, such as files, sockets, and database connections. By automating the closing process and reducing boilerplate code, it helps prevent resource leaks and makes code cleaner and more maintainable.
	
	try (FileInputStream fis = new FileInputStream("file.txt");
     BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {

    // Use the resources
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }

	} catch (IOException e) {
		// Handle exceptions
		e.printStackTrace();
	}

37. Checked & Unchecked Exception	
	1. Checked Exceptions  (Compile-Time exception)
		Definition: Checked exceptions are exceptions that must be either caught or declared in the method signature using the throws keyword. They represent conditions that a reasonable application might want to catch, such as file not found, database connection errors, or other recoverable situations.
		
		Compile-Time Checking: The Java compiler checks that checked exceptions are either caught in a try-catch block or declared in the method's throws clause. If not handled properly, the code will not compile.

		Examples:

		IOException
		SQLException
		FileNotFoundException
		ClassNotFoundException

	2. Unchecked Exceptions (Runtime exception)
		Definition: Unchecked exceptions are exceptions that do not need to be declared in a method signature throws clause and do not need to be caught. They represent programming errors, such as logic errors or improper use of an API.

		Examples:

		NullPointerException
		ArrayIndexOutOfBoundsException
		ArithmeticException
		IllegalArgumentException


38. What is Collection in Java?
	The term collection refers to a group of objects represented as one unit.	
	
39.What are the various interfaces used in Java Collections Framework?
	The collection is known as the root of the collection hierarchy. Collections represent groups of objects known as elements. The java platform does not provide any direct implementation of this interface but the Collection interface is being implemented by List and Set classes.

	Collection interface
	List interface
	Set interface
	Queue interface
	Dequeue interface
	Map interface

40 Define enum ?
	In Java, an enum (short for "enumeration") is a special data type that represents a group of constants (unchangeable variables). An enum is particularly useful when you have a fixed set of related values that are known at compile time, such as days of the week, directions, states of a process, etc.
	Enums are preferable in Java because they are designed to handle the use case of a fixed set of constants with minimal boilerplate and built-in type safety.
	All enums implicitly extend java.lang.Enum, so they inherit several useful methods, such as name(), ordinal(), and valueOf().
	Enum constants are implicitly public, static, and final, which means they cannot be changed once created.
	
	Day today = Day.MONDAY;
    System.out.println("Today is: " + today.name()); // gets monday as op
	System.out.println("Ordinal of today: " + today.ordinal()); // get position
	Day day = Day.valueOf("FRIDAY");
	
	public enum Day {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}

	public class EnumExample {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        
        // Enum in a switch statement
        switch (today) {
            case MONDAY:
                System.out.println("Mondays are tough!");
                break;
            case FRIDAY:
                System.out.println("Fridays are great!");
                break;
            default:
                System.out.println("Midweek days are okay.");
                break;
        }
        
        // Enum methods
        System.out.println("Today is: " + today.name());
        System.out.println("Ordinal of today: " + today.ordinal());
    }
}


41. What is Collection in java ? 

	In Java, the Collection framework provides a unified architecture for representing and manipulating collections of objects. 
	The framework includes interfaces and classes that allow you to work with different types of collections such as lists, sets, and queues. 
	The Collection interface is the root interface in the collection hierarchy, and various classes implement this interface to provide specific functionalities.

	Collection Interface: The root interface for all collections in Java, providing basic methods to manage groups of objects.
	Subinterfaces: List, Set, Queue, Deque, and others extend Collection to provide more specific behaviors.
	Implementing Classes: Classes like ArrayList, LinkedList, HashSet, TreeSet, and PriorityQueue implement these interfaces to provide concrete implementations with specific behaviors and performance characteristics.

42.List
	Key Characteristics of the List Interface
		Ordered Collection: (follows insertion order)
		Allows Duplicates:
		Indexed Access:
		Flexible Insertion and Removal:

	ArrayList, LinkedList, Vector, or Stack.
	
	ArrayList:
		Underlying Data Structure: Dynamic array.
		A resizable array implementation of the List interface.
		Provides fast random access to elements due to its backing array.
		It is not synchronized (not thread-safe).
		Memory Usage: Less memory overhead compared to LinkedList because it stores elements in a contiguous block of memory.
		Use Case: Suitable for applications where frequent access to elements by index is required and insertions/deletions are infrequent.
	LinkedList:
		Underlying Data Structure: Doubly linked list.
		A doubly-linked list implementation of the List and Deque interfaces.
		Provides better performance for inserting or removing elements from the middle of the list.
		Memory Usage: More memory overhead compared to ArrayList because it stores additional pointers for the previous and next elements.
		Use Case: Suitable for applications where frequent insertions and deletions are required, especially at the beginning or end of the list.
	Vector:
		Similar to ArrayList, but synchronized (thread-safe).
		Due to synchronization overhead, it is generally slower than ArrayList.
	Stack:
		A subclass of Vector that implements a last-in, first-out (LIFO) stack.
		Provides methods like push(), pop(), and peek().
		Stack additionally provides push() for adding elements.
		Stack uses pop() to remove the top element.

	Collections.synchronizedList() can provide synchronized access to other list implementations like ArrayList
	
	The default initial capacity of an ArrayList is 10 This means when you create an ArrayList without specifying the capacity, it starts with a capacity of 10.
	When the ArrayList exceeds its capacity, it grows by 50% of its current size. 

	 // Creating a non-synchronized list
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        
        // Making the list synchronized
        List<String> synchronizedList = Collections.synchronizedList(list);
        
        // Example of thread-safe operations on the list
        synchronized (synchronizedList) {
            for (String fruit : synchronizedList) {
                System.out.println(fruit);
            }
        }
		
	
	
		
	 // Creating a list using ArrayList
	List<String> list = new ArrayList<>();
	
	// Adding elements
	list.add("Apple");
	list.add("Banana");
	list.add("Cherry");
	
	// Accessing elements
	System.out.println("Element at index 1: " + list.get(1));  // Banana
	
	 // Sorting the list in natural (alphabetical) order
		Collections.sort(list);
	
	 // Sorting the list in ascending order
        numbers.sort(null); // Same as Collections.sort(numbers)
	
	// Modifying elements
	list.set(1, "Blueberry");
	System.out.println("Modified list: " + list);  // [Apple, Blueberry, Cherry]
	
	// Removing elements
	list.remove(0);
	System.out.println("After removing first element: " + list);  // [Blueberry, Cherry]
	
	// Iterating over elements
	for (String fruit : list) {
		System.out.println(fruit);
	}
	
	// Using a ListIterator
	ListIterator<String> iterator = list.listIterator();
	while (iterator.hasNext()) {
		System.out.println("Iterator next element: " + iterator.next());
	}
	
	// Creating a sublist
	List<String> sublist = list.subList(0, 1);
	System.out.println("Sublist: " + sublist);  // [Blueberry]


43.Set 
	The Set interface in Java is a part of the Java Collections Framework and represents a collection that does not allow duplicate elements. It models the mathematical set abstraction and is used when you want to store unique elements, i.e., no element should occur more than once.
	
	Key Characteristics of the Set Interface
		No Duplicate Elements:
		Unordered Collection:
		No Positional Access:
	
	
	Use Set when you need to store a collection of unique elements.
	HashSet 
		when you don't care about the order of elements and need fast access.
	LinkedHashSet 
		when you want to maintain the order of insertion.
	TreeSet 
		when you need the elements to be sorted.
	
	  Set<String> hashSet = new HashSet<>();
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Cherry");
        hashSet.add("Apple"); // Duplicate, will be ignored
		
		hashSet.remove("Cherry");
		hashSet.contains("Banana")
		hashSet.size()
        hashSet.clear();

		Convert the Set to a List using new ArrayList<>(set).
		Sort the List using Collections.sort(list).
		
		Set<String> synchronizedSet = Collections.synchronizedSet(originalSet);  - Thread Safe
		
		CopyOnWriteArraySet - thread safe
		Set<String> set = new CopyOnWriteArraySet<>();
        set.add("Apple");
        set.add("Banana");

44.Map	
	The Map interface in Java represents a collection of key-value pairs where each key maps to exactly one value. It is part of the Java Collections Framework and provides a way to store and retrieve data based on keys. The Map interface does not extend the Collection interface, and it has several important implementations and subinterfaces.
	
		Key-Value Pair Storage:
		No Duplicate Keys:
		Value Access by Key:
		No Guarantee of Order:

	HashMap:
		
			Map<String, Integer> hashMap = new HashMap<>();
			System.out.println(hashMap.put("Apple", 3)); //null
				//The put method inserts the key "Apple" with the value 3 into the hashMap.
				//Since "Apple" is a new key, there is no previous value associated with it.
				//The put method returns null when there is no previous value for the key.
			System.out.println(hashMap.put("Apple", 4));// 3
				//The put method updates the value for the key "Apple" to 3 again.
				//Since "Apple" already exists in the hashMap with the value 3, the put method returns the previous value associated with the key, which is 3.
		
		Implements the Map interface and uses a hash table.
		Does not guarantee the order of its elements.
		Provides constant-time performance for basic operations like get and put
		
		HashMap h  = new HashMap();
		creates an empty hashmap object with default initial capacity 16
		and default fill ratio is 0.75
		
		HashMap m = new HashMap(int intialCapacity);
		set specified inital capcaity with default fillratio is 0.75
		
		HashMap m = new HashMap(int intialCapacity, flaot fillCapacity);
		set specified inital capcaity with specified fillratio 
	
		Map<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Apple", 3);
		 
		System.out.println("HashMap: " + hashMap);
		System.out.println("Value for 'Banana': " + hashMap.get("Banana"));

		hashMap.remove("Cherry");
		System.out.println("After removing 'Cherry': " + hashMap);

		System.out.println("Keys: " + hashMap.keySet());
		System.out.println("Values: " + hashMap.values());
		System.out.println("Entries: " + hashMap.entrySet());
		
		// Iterate using forEach and Lambda
        map.forEach((key, value) -> {
            System.out.println("Key: " + key + ", Value: " + value);
        });
		
	
	Map m = Collections.SynchronizedMap(m);

	LinkedHashMap:
		Extends HashMap and maintains a linked list of entries.
		Maintains the order of insertion.

	TreeMap:
		Implements the NavigableMap interface and stores elements in a sorted order based on their keys.
		Provides a natural ordering of keys or a comparator if provided.
	
	ConcurrentHashMap
		Characteristics: A thread-safe variant of HashMap that allows concurrent access by multiple threads. It does not guarantee the order of elements.
		Use Case: For concurrent applications where thread safety is required
		No Null Keys/Values
	
	WeakHashMap
		Characteristics: Implements Map where keys are weakly referenced. If a key is no longer in ordinary use, it can be collected by the garbage collector.
		Use Case: When you need to maintain references to objects that can be garbage collected.
	
	IdentityHashMap
		Characteristics: Uses reference equality (==) instead of object equality (equals()) for keys and values.
		Use Case: When you need to compare keys and values by reference rather than by value.
	
	NavigableMap
		Characteristics: Extends SortedMap with navigation methods for dealing with elements in a sorted order, like lowerEntry, floorEntry, ceilingEntry, and higherEntry.
		Use Case: When you need to navigate through a sorted map efficiently.
	SortedMap
		Characteristics: Extends Map to handle keys in a sorted order. Provides methods like firstKey() and lastKey().
		Use Case: When you need a map where keys are sorted.

	Key Methods of the Map Interface
		put(K key, V value):
			Associates the specified value with the specified key. If the key already exists, the old value is replaced.
		get(Object key):
			Returns the value associated with the specified key.
		remove(Object key):
			Removes the mapping for the specified key if it is present.
		containsKey(Object key):
			Returns true if the map contains a mapping for the specified key.
		containsValue(Object value):
			Returns true if the map maps one or more keys to the specified value.
		keySet():
			Returns a Set view of the keys contained in the map.
		values():
			Returns a Collection view of the values contained in the map.
		entrySet():
			Returns a Set view of the mappings contained in the map.
		clear():
			Removes all mappings from the map.
		size():
			Returns the number of key-value pairs in the map.
	
##.HashMap vs HashTable
	HASHMAP
		Not Synchronized
		Not ThreadSafe
		Pefromance is highl
		null key & value is allowed
	HASHTABLE
		Synchronized
		ThreadSafe
		Pefromance is low
		null key & value is not allowed
		
##. Guess output
	Hashtable<String, String>  ht = new Hashtable<String, String>();
	ht.put(new String("1"), "one");
	ht.put("1",ht.put(new String("4"), "five")); //throws null pointer exception since for key 4 is  there is no previous value associated with it. 
												//The put method returns null when there is no previous value for the key since HashTable doesnt allow null key and value

		
##.HASHMAP INTERNAL IMPLEMENTATION
	
	Hashing: When you put a key-value pair into a HashMap, the key's hashCode method is called to compute a hash value. This hash value determines the bucket (or slot) in the internal array where the entry will be stored

	Buckets: The HashMap uses an array of nodes (buckets) to store the entries. Each bucket can hold multiple entries, and the position of each entry is determined by the hash value of its key

	Storing Entries: Each entry in the HashMap is stored as a node containing:

	The hash value.
	The key.
	The value.
	A reference to the next node (if there is a collision, i.e., multiple entries in the same bucket)
	Handling Collisions: When two keys have the same hash value, they are stored in the same bucket. In such cases, the entries are stored in a linked list within that bucket. From Java 8 onwards, if the number of entries in a bucket exceeds a certain threshold, the linked list is converted into a balanced tree (Red-Black Tree) to improve performance
	
##FAIL FAST AND FAIL SAFE ITERATOR
	FAIL FAST : 
		A Iterator which will fail when we do any modification while iterating a collection is called failfast iterator
		Throws ConcurrentModificationException if there is any modification while iterating
			Ex : ArrayList, HashMap & Vector
	FAIL SAFE : 
		A iterator which allow us to modify in middle while iterating a collection is called failsafe iterator
			Ex : CopyOnWriteArrayList, CopyOnWriteArraySet, ConcurrentHashMap
				
	
##.HASHMAP VS ConcurrentHashMap vs HashTable vs Collections.synchronizedMap(map)
	HASHMAP : 
		Non Synchronized
		Not thread safe
		Fail fast throws exception during modification ConcurrentModificationException
		allows null keys/values
		faster
	ConcurrentHashMap
		Synchronized
		ThreadSafe
		FailSafe
		doesnt allow null key/values
		slower
		ConcurrentHashMap allows concurrent read and write operations, while SynchronizedMap does not.
		ConcurrentHashMap does not throw ConcurrentModificationException if one thread modifies the map while another is iterating over it, whereas SynchronizedMap can
	HashTable
		Locking mechanism as per hashmap there is no segment like individual bucket
	
	Collections.synchronizedMap(map)
		it will act as Synchronized hashtable only where again locking mechanism is different like locking mechanism is locked the entire map not individual bucket 
		SynchronizedMap locks the entire map for each operation (e.g., put, get, remove). This means only one thread can access the map at a time, leading to potential bottlenecks.

45.Queue
	Queue Interface
	Definition: Represents a collection of elements that are processed in a FIFO (first-in, first-out) manner.
	Key Methods:
		add(E e): Inserts an element into the queue. Throws an exception if it fails.
		offer(E e): Inserts an element into the queue. Returns true if successful.
		remove(): Retrieves and removes the head of the queue. Throws an exception if the queue is empty.
		poll(): Retrieves and removes the head of the queue. Returns null if the queue is empty.
		peek(): Retrieves but does not remove the head of the queue. Returns null if the queue is empty.
		element(): Retrieves but does not remove the head of the queue. Throws an exception if the queue is empty.
	2. LinkedList
		Definition: Implements Queue using a doubly-linked list.
		Characteristics: Allows efficient insertion and removal from both ends.
		Use Case: General-purpose queue with efficient add and remove operations.
	3. PriorityQueue
		Definition: Implements a priority queue where elements are ordered based on priority.
		Characteristics: Does not follow FIFO order; higher priority elements are dequeued first.
		Use Case: When you need to process elements based on their priority.
	4. ArrayDeque
		Definition: Implements a double-ended queue (deque) using a dynamic array.
		Characteristics: Allows insertion and removal of elements from both ends and is faster than LinkedList for queue operations.
		Use Case: When you need a queue with efficient operations on both ends.
	5. BlockingQueue
		Definition: Extends Queue to support blocking operations.
		Characteristics: Useful for thread-safe operations where threads may need to wait if the queue is full or empty.
		Use Case: Producer-consumer scenarios and concurrent processing.
	6. Deque (Double-ended Queue)
		Definition: Extends Queue to allow insertion and removal from both ends.
		Characteristics: Supports operations at both the front and the back of the queue.
		Use Case: When you need to perform operations on both ends of the queue.


46.HashCode
	hashCode() method returns the hashcode value as an Integer. It is defined in the Java Object class which computes the hash values of given input objects. Hashcode value is mostly used in hashing-based collections like HashMap, HashSet, HashTable
	
	The hashCode() method returns an integer hash code value for an object. This hash code is used primarily to identify objects in hash-based collections.
	
	Hash-Based Collections: In collections like HashMap and HashSet, the hashCode() method helps determine the bucket location where an object should be stored or retrieved. It allows these collections to perform quick lookups, insertions, and deletions.

	Object Identity: The hashCode() method provides a way to get a unique identifier for objects, although it's not guaranteed to be unique. It helps in managing and organizing objects efficiently in hash-based data structures.


47.Iterator vs enum
	 It is a universal iterator as we can apply it to any Collection object. By using an Iterator, we can perform both read and remove operations.
	  Enumeration (or enum) is a user-defined data type. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain. 
	  Enumeration is a legacy interface that is used for traversing Vector, and Hashtable.
	  
48 Comparable vs Comparator
		
	Comparable:
		Comparable provides a single sorting sequence i.e we can sort sorting based on id or name or price
		Effects original class i.e actual class is modified
		provides compareTo() method to sort elements
		present in java.lang package
		we can sort elements by Collections.sort(List)
			

		public class Person implements Comparable<Person> {
			private String name;
			private int age;

			public Person(String name, int age) {
				this.name = name;
				this.age = age;
			}

			@Override
			public int compareTo(Person other) {
				return Integer.compare(this.age, other.age); // Sort by age
			}

			@Override
			public String toString() {
				return name + " (" + age + ")";
			}

			public static void main(String[] args) {
				List<Person> people = new ArrayList<>();
				people.add(new Person("Alice", 30));
				people.add(new Person("Bob", 25));
				people.add(new Person("Charlie", 35));

				Collections.sort(people); // Sort using the natural ordering defined in compareTo
				System.out.println("Sorted by age: " + people);
			}
		}
		
		we can do above way or below
	1.return o1.compareTo(o2); //ascending order
	2.return -o1.compareTo(o2);//descending order
	3.return o2.compareTo(o1);//descending order
	4.return o1.compareTo(o2); //ascending order
	5.return +1; insertion order
	6.return -1; reverse of insertion order
	7. return 0; only first element is inserted remaining all duplicate and wont be added

	Comparator:
		Comparable provides a multiple sorting sequence i.e we can sort sorting based on id name and price
		Doesn't Effects original class i.e actual class is not modified
		provides compare() method to sort elements
		present in java.util package
		we can sort elements by Collections.sort(List, Comparator)

		public class PersonComparatorExample {
			public static void main(String[] args) {
				List<Person> people = new ArrayList<>();
				people.add(new Person("Alice", 30));
				people.add(new Person("Bob", 25));
				people.add(new Person("Charlie", 35));

				// Sort by name
				Comparator<Person> nameComparator = new Comparator<Person>() {
					@Override
					public int compare(Person p1, Person p2) {
						return p1.name.compareTo(p2.name);
					}
				};

				Collections.sort(people, nameComparator);
				System.out.println("Sorted by name: " + people);

				// Sort by age using lambda expression
				Comparator<Person> ageComparator = (p1, p2) -> Integer.compare(p1.age, p2.age);
				Collections.sort(people, ageComparator);
				System.out.println("Sorted by age: " + people);
			}
		}
		
		// Sort employees by name using Streams with lambda expression
        List<Employee> sortedByName = employees.stream()
            .sorted((e1, e2) -> e1.getName().compareTo(e2.getName()))
            .collect(Collectors.toList());
			
##.write a program to insert integer object into the treeset where the sorting order is descending order	
	1.
	TreeSet<Integer> treeSet = new TreeSet<>(Comparator.reverseOrder());

	2.	//here we are using our own customized sorting order else default it used naturalsorting order as treeset
		Set<Integer> set = new TreeSet<>(new MyComparator());
		 set.add(10);
		 set.add(20);
		 System.out.println("Custom sorting using TREE SET : " +set); 	
		 
		 public class MyComparator implements Comparator<Integer>{

			@Override
			public int compare(Integer o1, Integer o2) {
				// TODO Auto-generated method stub
				if(o1<o2)
					return 1;
				if(o1>o2)
					return -1;
				return 0;
			}
			
		}

##.	Collections vs Collections
		Collection
			is an interface
			to represent group of objects into a single entity
		Collections
			is a class
			is a utility class which defines several utility methods like searching sorting  present in java.util package for collection object
				ex Collections.sort(arrayList)

49.what is functional programming ?
	Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. 

50.Try CATCH	
	In Java, it's not allowed to use a try block without either a catch block or a finally block. A try block must be followed by at least one catch block or one finally block
	The try block is used for handling exceptions that might occur during the execution of a block of code. When you use try, you typically pair it with either a catch block (to handle exceptions) or a finally block (to execute code regardless of whether an exception was thrown).
	
	The throws keyword is used in a method signature to declare that the method might throw one or more exceptions. When a method declares throws, it indicates that the method does not handle certain exceptions internally and instead passes the responsibility for handling those exceptions to the caller of the method.
	
	whenever we are writing finally block it mustbe with try else throw compile time error
	
	curly braces are mandatory for try catch finally

51. Error vs Exception
	Throwable acts as root for exception hierarchy 
	Throwable contains two child classes 
	1.Exception 
	2.Error
	Exception : 
		In most of the cases Exception is caused by our program
		Exceptions are recoverable
		if file not found then in catch we can use other path ad continue this is recoverable
		try{
			//fetch file from C:/usr/app
		}Catch(Error e){
			//fetch from D:/usr/app and continue
		}
	Error : Most of the time errors are not caused by program they re due to lack of system resources
		Errors are not recoeverable
		Ex : out of memory error, StackOverflowError
		Errors represent serious problems that a reasonable application should not try to catch. They are typically external to the application and indicate issues related to the Java Virtual Machine (JVM) or the runtime environment.


52. Diff between Parent p = new Child(); vs Child c = new Child();

	Parent p = new Child();
		Reference Type: Parent
		Object Type: Child
		You can use p to access methods that are in Parent, but if they are overridden in Child, the Child version will be used.
		You cannot call Child-specific methods directly using the p reference, as the reference is of type Parent.
		
		If we dont know exact runtime type of the object then we should use this (Polymorphism) 

	Child c = new Child();
		Reference Type: Child
		Object Type: Child
		you can access all methods and properties of Child, including those inherited from Parent.
		There’s no restriction on accessing Child-specific methods.
		
		Child c = new Child();
        c.display();           // This calls Child's display method

        // Call Parent's display method directly using casting
        ((Parent) c).display(); // This calls Parent's display method
		
		
		If we know exact runtime type of the object then we should use this
		
53.Final Finally Finalize
	final: Used to declare constants, prevent method overriding, and prevent inheritance.
	finally: Used for code that must be executed after a try-catch block, typically for resource cleanup.
	finalize: A method called by the garbage collector before an object is removed from memory, though its use is discouraged and deprecated in newer Java versions.	


2.What is Concurrent hashmap ?
	ConcurrentHashMap is a thread-safe, high-performance variant of HashMap in Java that allows concurrent access to the map without the need for external synchronization
	Null Keys or Values not allowed
	ConcurrentHashMap provides atomic operations such as putIfAbsent(), remove(), and replace(),
	map.putIfAbsent("key", "value"); // Adds the key-value pair only if the key is not already present.
	map.replace("key", "oldValue", "newValue"); // Replaces the value for the key only if it is currently mapped to oldValue.
	Lock-Free Reads: In Java 8, ConcurrentHashMap uses a lock-free mechanism for read operations, which means that multiple threads can read from the map without blocking each other.
	CAS Operations: Write operations (like put, remove, etc.) are implemented using Compare-And-Swap (CAS) operations, which are low-level atomic operations that help in achieving thread safety with minimal locking.
	Bucket Locking: Instead of locking the entire map, ConcurrentHashMap uses finer-grained locking by locking individual buckets or entries. This reduces contention and improves performance.
	
3.what is Garbage Collector ? 
	The Garbage Collector (GC) in Java is a form of automatic memory management that is responsible for reclaiming memory occupied by objects that are no longer in use by the application. It frees up memory by identifying and disposing of objects that are no longer reachable from any live thread, thereby preventing memory leaks and optimizing the use of memory in Java applications.
	
	Types of Garbage Collectors in Java
		Serial Garbage Collector:
			A simple, single-threaded GC that is suitable for small applications or single-threaded environments.
			It pauses all application threads during garbage collection (stop-the-world event).
		Parallel Garbage Collector (also known as Throughput Collector):
			Uses multiple threads to perform GC work, making it suitable for applications with high throughput requirements.
			It is a default collector for many Java versions.
		Concurrent Mark-Sweep (CMS) Garbage Collector:
			Focuses on reducing pause times by doing most of the work concurrently with the application's threads.
	How to Trigger Garbage Collection
		System.gc(): The System.gc() method suggests that the JVM run the garbage collector, but it is not guaranteed. The JVM decides whether to perform garbage collection based on its own heuristics.
	
		MyObject obj1 = new MyObject();
        MyObject obj2 = new MyObject();

        obj1 = null; // obj1 is now eligible for garbage collection

        System.gc(); // Suggest the JVM to run the garbage collector

        obj2 = null; // obj2 is now also eligible for garbage collection

        // The actual garbage collection may happen at any time after the objects become unreachable

4.How garbage collector are started ?
	In Java, the Garbage Collector (GC) is automatically managed by the Java Virtual Machine (JVM). The JVM decides when to start the garbage collection process based on the application's memory usage and other internal heuristics. Here’s how and when the garbage collector is started:

	1. Automatic Trigger by JVM:
		Memory Pressure: The JVM monitors memory usage in the heap. When the heap usage reaches a certain threshold, the JVM may trigger garbage collection to free up memory. This is the most common way garbage collection is initiated.
		Generation Thresholds: In generational garbage collectors (like the G1, Parallel, or CMS collectors), garbage collection can be triggered when certain memory regions (like the Young Generation) reach their capacity.
		Full GC: When there is not enough free memory available, the JVM may trigger a full garbage collection, which is more comprehensive and attempts to reclaim memory from the entire heap, including both the Young and Old Generations.
	2. Manual Trigger by Code:
		System.gc(): Developers can suggest that the JVM performs garbage collection by calling System.gc(). However, this is only a suggestion, and the JVM is not obligated to run the garbage collector immediately or at all.
		Runtime.getRuntime().gc(): Similar to System.gc(), this method allows you to request garbage collection, but the JVM has the final decision on when or if to run the garbage collector.
	3. JVM Arguments:
		Garbage collection behavior can be influenced by specifying JVM arguments at startup. These arguments can control when the
		-XX:+UseG1GC: Enables the G1 Garbage Collector.
		
5.What are objects are deleted first when garbage collector is initiated ? 
	When the Garbage Collector (GC) is initiated in Java, it doesn't delete objects in a specific order based on a predefined sequence, but rather, it identifies and deletes objects based on their reachability and the generation they belong to within the heap.

	

6.StringBuffer & StringBuilder
	String s1 = "sa"; uses string pool
	String s2 = new String("sa"); uses heap memory

	StringBuffer: Thread-safe, synchronized, generally slower due to synchronization overhead. Use it when you need a mutable string in a multi-threaded environment.
	StringBuilder: Not thread-safe, unsynchronized, generally faster due to the lack of synchronization. Use it when working with mutable strings in a single-threaded environment.

what is the difference between using a class with object and inheriting it 

**************************************MULTITHREADING START*******************************

Threads are lightweight processes within processes as seen. In java, there are two ways of creating threads namely via Thread class and via Runnable interface.

		1.class MyThread extends Thread {
		2.class ThreadUsingInterface implements Runnable {

	There are two types of threads in Java as follows:
		User thread : User threads are created by java developers for example Main thread. All threads are created inside the main() method are user threads
		Daemon thread:  Daemon thread is a low-priority thread that runs in the background to perform tasks such as garbage collection,

	Thread Lifecycle
		New (or Born) State:
			When a thread instance is created using the new Thread() constructor, it is in the New state. At this point, the thread is not yet started.
		Runnable State:
			A thread enters the Runnable state when the start() method is invoked. In this state, the thread is ready to run and is waiting for CPU time to be scheduled for execution. Note that in the Runnable state, the thread may not necessarily be running but is ready to run.
		Blocked State:
			A thread moves to the Blocked state when it wants to access a synchronized block or method but is waiting for the lock to be released by another thread.
		Waiting State:
			A thread enters the Waiting state when it is waiting indefinitely for another thread to perform a particular action (e.g., waiting for a notification via Object.wait()).
		Timed Waiting State:
			Similar to the Waiting state, but the thread is waiting for a specified period. This can occur when using methods like Thread.sleep(), Object.wait(long timeout), or Thread.join(long millis).
		Terminated (or Dead) State:
			A thread enters the Terminated state when it has completed its execution or has been terminated due to an exception. The thread is no longer alive and cannot be started again.

	sleep(long millis):
		Purpose: Pauses the current thread for the specified number of milliseconds. The thread is not active during this time.
	
	wait()
		public void wait() throws InterruptedException
		Purpose: Causes the current thread to wait until another thread invokes notify() or notifyAll() on this object.
	notify()
		public void notify()
		Purpose: Wakes up a single thread that is waiting on this object's monitor
			
			
			public class ThreadLifecycleExample {
				public static void main(String[] args) {
					Thread thread = new Thread(new MyRunnable());

					// New state
					System.out.println("Thread state: " + thread.getState());

					thread.start(); // Runnable state

					// Runnable state
					System.out.println("Thread state: " + thread.getState());

					try {
						Thread.sleep(100); // Main thread sleeps to allow MyRunnable to run
					} catch (InterruptedException e) {
						e.printStackTrace();
					}

					// Terminated state
					System.out.println("Thread state: " + thread.getState());
				}
			}

			class MyRunnable implements Runnable {
				@Override
				public void run() {
					// Running state
					System.out.println("Thread is running");

					synchronized (this) {
						try {
							wait(50); // Timed Waiting state
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}

					// Running state
					System.out.println("Thread is running again");
				}
			}


Durga  12-08-2024
MultiThreading

New: When a thread is created but not yet started.
Runnable: When a thread is ready to run and is waiting for CPU time.
Blocked: When a thread is blocked waiting for a resource.
Waiting: When a thread is waiting indefinitely for another thread to perform a specific action.
Timed Waiting: When a thread is waiting for a specified amount of time.
Terminated: When a thread has finished execution.


Thread : Thread is an execution of a process
Thread Schedular is part of jvm Thread schedular is responsible for executing the threads 
thread schedular will decide in which order threads are going to execute

in multithreading we should not expect ordered output

If two independent jobs are there then only we need to choose multithreading if there is dependency we should not go for multithreading


MyThread t = new MyThread();
t.start();

Incase of t.start() a new thread will be created which is responsible for the execution of run method 
but in case of t.run() a new thread wont be created and run method will be executed just like normal call by main thread hence in the above program if we replacee t.start() with t.run() then thr output 

		public class ThreadDemo {

			public static void main(String[] args) {

				MyThread t = new MyThread(); //thread initiation till now only one thread
				t.start();// another thread started
				
				for(int i=0;i<4;i++) {
					System.out.println("Parent Thread");
				}
			}
		}

		public class MyThread extends Thread{
			
			/*
			 * public void run(){
			 * 
			 * for(int i=0; i<4;i++) { System.out.println("Child Thread"); } }
			 */
		}


ChildThread
ChildThread
ChildThread
MainThread
MainThread
MainThread

this total output is produced by only main thread

Case 3: importance of Start() Method
Start()
	1.thread class start method is responsible to Register the thread with thread scheduler 
	2.perform all the other mandatory activites 
	3.Invoke run();
	4.hence without thread class start method there is no chance of starting new thread in java due to this start method is considered as heart of multithreading

Case 4 : Overloading of run() method
	overloading of run method is always possible but thread class start() can invoke no ard run() method
	The other overloaded method we have to call explicitly like a normal method call
	
	package com.project.springbootdemo.thread;

	//	Run Method overloading
	
	public void run() {
		System.out.println("no arg method");
	}
	
	public void run(int i) {
		System.out.println("int arg method "+i);
	}

Case 5 : If we  are not overriding run method
	if we dont overriding run method it will execute thread class run method which has empty implementation henc e we wont get any output 
	
	//no output
	
	it is highly to overrride run method otherwise dont go for multuthreading concept
	
Case 6 : Overriding of start method
	if we override start method our start method will be executed just like normal method call and new thread wont be created
	Since jvm first checks start method iif it present in  MyThread class it is present so it will execute Start present in MyThread
	
	
	public void start() {
		System.out.println("start method");
		
	}
	
	public void run() {
		System.out.println("run method");
		
	}
	
	//output
	start thread
	main thread
	
	hence it is produce by only main thread
	it is not recommended to override start method otherwise dont go for multithreading concept
	
case 7 : using super.start();
	public void start() {
	super.start();
		System.out.println("start method");
		
	}
	
	public void run() {
		System.out.println("run method");
		
	}
	
	public static void main(String[] args) {

		MyThread t = new MyThread(); //thread initiation till now only one thread
		t.start();// another thread started
		
		System.out.println("Parent/ Main Thread");
		
	}
13-08-24
Possible outputS
	1	start
		run
		main
	2	run
		start
		main
	3	start
		main
		run
	
	main method in line 1 is not possible because 
	start method and main method is of same thread 
	run method is different thread 
	Inside thread it is sequential approach
	parallel execution no no sequential approach

case 8: Thread lifecycle
	Thread t = new Thread();
	t.start();
	System.out.println("Parent/ Main Thread");
	t.start();
	If we tried to start a thread which is already started immediately we get run time exception of IllegalThreadStateexception

Video 3
	We can define a thread by 
		1.Thread class like extending
		2.Runnbale interface like implements
	internally thread class implements Runnable interface
	Runnable interface present in java.lang package and it contains only 1 method run()
		public void run()
	
	public class MyRunnable implements Runnable {
	
	public void run() {
		
		for(int i=0;i<3;i++) {
			System.out.println("Child Thread");
		}
	}
	
	//		using runnable interface
		MyRunnable r = new MyRunnable();// runnable interface doesnot have start method
		Thread thread = new Thread(r);//so we need to create thread class object and pass object of the class which implements runnable interface
		
		thread.start();
		
		for(int i=0;i<3;i++) {
			System.out.println("main thread");
		}

CASE STUDY
	MyRunnable r = new MyRunnable();
	Thread t1 = new Thread();
	thread t2 = new Thread(r);
	
	Case 1 : t1.start();
		A new thread will be created which is responsible for the execution of thread class run method, which  has empty implementation
	Case 2 : t1.run();
		No new thread will be created and thread class run method will be executed just like a normal method call
	Case 3 : t2.start();
		a new thread will be created which is responsible for the execution of MyRunnable class run method
	Case 4 : t2.run 
		A new thread wont be created and MyRunnable run method will be executed just like normal method call
	Case 5 : r.start()
		we will get compile time error saying myrunnable class doesnt have start capability
			cannot find the symbol method start() location class myrunnable 
	Case 6 : r.run()
		no new thread will be created and myrunnbale run method will be executed like normal method call
	
Among two ways of implementing thread
	implementing Runnable is always recommended
	
	public class MyThread extends Thread{
	
		public class MyThread extends Thread{
		  public void run(){
		  
			  for(int i=0; i<4;i++) { System.out.println("Child Thread"); } 
			} 
		}
	} 
	public class MyRunnable implements Runnable {
		
		public void run() {
			
			for(int i=0;i<3;i++) {
				System.out.println("Child Thread");
			}
		}
	}
	
Which approach is best to define a thread
	Among two way of defining a thread implements runnable approach is recommended 
	in first approach using thread class our class always extends thread class there is no chance of extending any other class hence we are missing inheritance benefit
	But in the second while implementing runnable interface we can extend any other class hence we wont miss any inheritance benefit 
	becuase of above reason implementing runnnbale interface approach is recommended than extending thread class
	
Thread class constructors
	1.Thread t = new Thread();
	2.Thread t = new Thread(Runnable r);
	3.Thread t = new Thread(String name);
	4.thread t = new Thread(Runnable r, String name);
	5.thread t = new Thread(ThreadGroup g, String name);
	6.thread t = new Thread(ThreadGroup g, Runnable r);
	7.thread t = new Thread(Threadgroup g, Runnable r, String name);
	8.thread t = new Thread(Threadgroup g, Runnable r, String name, long StackSize );
	
Durga's Approach to define a thread	(not recommended to use)
		MyThread t = new MyThread();
		Thread t1 = new Thread(t);
		
		t.start();
		System.out.println("Parent/ Main Thread");
	
Getting & Setting name of Thread 
	Every thread in java have some name it may be default name genertaed by jvm or customised name provided by programmer
	We can get and set name of a thread by using  the foloowing 2 methods of thread class
		1.public final String getName();
		2.public final void setName();
	
	   psvm(){	System.out.println(Thread.currentThread().getName());//main
		MyThread t = new MyThread();
		System.out.println(t.getName()); //Thread-0 default thread name is thread-0 here 0,1,2 anything based on thread number of main thread
		System.out.println(Thread.currentThread().getName());  // will get current executing thread name
		t.setName("Nikhil");
		System.out.println(t.getName());}
	
	Thread.currentThread().getName());  // will get current executing thread name
	
VIDEO 4
Thread Priorities
	Every thread in java has some priority it may be default priority generated by jvm or cutomised priority provided by programmer
	The valid range of thread priority is 1 to 10 where 1 is MIN PRORITY 10 is MAX PRIORITY
	thread class defines some standard priorites they are
		Thread.MIN_PRIORITY - 1
		Thread.NORM_PRIORITY - 5
		Thread.MAX_PRIORITY - 10
	
	Thread Schedule will use the prirites while allocating processor
	Thread which is having highest priority will get chance first
	
	if two threads having same priority then we cant expect exact execution order it depends on thread scheduler
	
	Thread class defines following methods to get & set prorites of thread
	
	public final int getPriority();
	public final void setPriority(int p);
	Allowed values range 1 to 10
	if we give out of range like 0 or more than 10 then we get IllegalArgumentException
	
	t.setPriority(1); valid
	t.setPriority(20); //invalid
	
	Default PRORITY
		The default prority only for main thread is 5 but all remaining threads defafult prorities from parent to child that is what ever priority parent thread has will be there for the child thread
		
		System.out.println(Thread.currentThread().getPriority());//5
//		Thread.currentThread().setPriority(17); //Exception in thread "main" java.lang.IllegalArgumentException
		Thread.currentThread().setPriority(7);//7
		System.out.println(Thread.currentThread().getPriority());
		MyThread t = new MyThread();
		System.out.println(t.getPriority());//7
	
	**For MyThread Class parent class is Thread
		MyThread Class parent thread is main Thread
		
		MyThread t = new MyThread();
		t.setPriority(10);
		t.start();
		
		for(int i=0;i<5;i++) {
			System.out.println("parent thread");
		}
		
		//output
			child thread
			parent thread
		if priority is not set
			both main and child thread have same priority 5 hence we cant execution order and exact output
			if we set main priority child thrid has priority 10 hence child thread get first priority followed by main thread
				child thread
				parent thread
			order can be anything order is not guaranted
			
	Note : Some platforms wont provide support for thread priority

VIDEO 5 18.5 hours left
14-08-24
	
we can prevent a thread execution by using the following methods
	1.yield()
	2.join()
	3.sleep()

	Yield(): 
		yield method causes to pause current executing thread to give the chance for remaining waiting threads of same priority 
		if there is no waiting thread or all waiting threads have low priority then same thread continue its execution 
		if multiple threads are waiting with same priority then which waiting thread will get the chance we cant expect it depends thread schedular 
		the thread which is yielded, when it will get chance once again it depends on thread schedular and we can't expect exactly
	
		public static native void yeild();
		At Thread.yield()
		
		public class MyThreadYield extends Thread{
		
		public void run() {
			
			for(int i=0;i<4;i++) {
				System.out.println("Child Thread");
				Thread.yield(); ------1
			}
		}
		
		}
		
		psvm(){
		MyThreadYield t = new MyThreadYield();
			t.start();
			
			for(int i=0;i<4;i++) {
				System.out.println("Main thread");
		}}
		
		in the above program if we are commenting line 1 then both the threads will be executed simulataneously and we cant expect which thread will complete first
		
		if we are not commenting line 1 child threada always calls yield method because of that main thread will get chance more no of times the chance of completing main thread first is high
		
		some platforms may not provide support for yield method underlying os wont provide support
	
	
	join(): 
		if a thread wants to wait until completing some other threads then we should go for join method
	
		for ex if a thread t1 wants to wait until completing t2 then t1 has to call t2.join
		if t1 executes t2.join then immediately t1 will be entered into waiting state until t2 completes 
		once t2 completes t1 can its execution
	
		public final void join()
		public final void join(long milliseconds)
		public final void join(long milliseconds, int nanoseconds) throws initeruppted exception
	
		every join method throws interupted exception which is checked exception compuslary we should handle this exception either by using try catch or by throws keyword otherwise we will get compile time error
		
		**
		t2.join()
		t2.join(1000)
		t2.join(1000,100)
		now the thread can enter into waiting state blocked for joining 
			if t2 compltes
			or if time expires
			or if waiting thread got interupted
		then automatically thread enters into runnable state if tread schedular allocates processor then thread goes to running state then thread enter into dead state 
		
		Waiting of main thread until completion of child thread
	
		public class MyThreadJoin extends Thread{

			public void run() {
				
				for(int i=0;i<5;i++) {
					try {
						Thread.sleep(2000);
						System.out.println("Seetha Thread");
					}catch(InterruptedException e) {
						System.out.println("Interupted at "+i);
					}
				}
			}
		}
	
	public static void main(String[] args) throws InterruptedException {
		
		MyThreadJoin t = new MyThreadJoin();
		t.start();------------------1
		t.join(6000);
		
		for(int i=0;i<5;i++) {
			System.out.println("Rama Thread");
		}
		
	}

	
	if we comment line 1 then both main & thread thread exected simultaneously and we cant expect exact output
	
	if we are not commenting line 1 then main thread call join method on child thread object hence main thread will wait until completion of child thread
	o/p	Seetha Thread
		Seetha Thread
		Seetha Thread
		Seetha Thread
		Seetha Thread
		Rama Thread
		Rama Thread
		Rama Thread
		Rama Thread
		Rama Thread

		
VIDEO 6 15-08-24

	
VIDEO 6 16-08-24

	Interrupt : 
	public void run() {
		try {
			for(int i=0;i<4;i++) {
				System.out.println("Child thread");
				Thread.sleep(2000);
			}
		}catch(InterruptedException e) {
			System.out.println("I am interrupted");
		}
	}
	
	MyThread t = new MyThread();
	t.start();
	t.interrupt();--------------(1)
	System.out.println("Main Thread");
	
	output
		Main Thread
		Child thread
		I am interrupted
	
	if we comment line 1 then main thread wont interrupt child thread
	if we are not commenting line 1 then main thread interrupt child thread in this case output is
		Main Thread
		Child thread
		I am interrupted
		
	Note : whenever we are calling Interrupt method if the taget thread nont in sleeping or waiting state there is no impact of interrupt call immediately interrupt call will be waited until taget thread entered into sleeping or waiting state
	If the target thread enter into sleeping or waiting state then immediately interrrupt call will interrupt target thread immediately
	if the target thread never enter intosleeping or waiting state in its lifetime there is no impact of interrupt call this is the only case where interrupt call is wasted
	
	public void run() {
		for(int i=0;i<4;i++) {
			System.out.println("Child thread");
			
		}
		System.out.println("Thread entering into sleeping state");
		try {
			Thread.sleep(2000);
		}catch(InterruptedException e) {
			System.out.println("I am interrupted");
		}
	}
		
	MyThread t = new MyThread();
	t.start();
	t.interrupt();
	System.out.println("Main Thread");
	
	Main Thread
	Child thread
	Child thread
	Child thread
	Child thread
	Thread entering into sleeping state
	I am interrupted

	Comparision table of yield, join and sleep method
	
	Yield : 
		Purpose : if a athread wants to pause its execution to give the chance for remaining threads of same priority then we should go for yeild method
		Overloaded : no
		Final : No
		Throws Interupted exception : No
		is it static : YES
	Join : 
		If a tread want s to wait until completion of other thread then we should go for join method
		Overloaded : YES
		Final : No
		Throws Interupted exception : YES
		is it static : NO
	sleep:
		if a thread dont want to perform any operation for a particualr amount of time 
		Overloaded : YES
		Final : No
		Throws Interupted exception : No
		is it static : YES
		
VIDEO 7 : 17-08-24
	SYNCHRONIZATION : 
	Synchronizer :  is the modifier applicable only for methods and blocks 
	If multiple threads are trying to operate simultaneously on the same java object then there may be  a chance of data inconsistency problem 
	to overcome this problem we should go for synchronizer keyword
	if a method or block declared as synchronizer then at a time only one thread is allowed to execute that method or block. on the given object so that data inconsistency problem will be resolved
	
		The main advantage of synchronizer keyword is we can resolve data inconsitency problems 
		but the main DISADVANTAGE of syncronizer keyword is it increases waiting time of threads and creates performnace problems hence if theee is no specific requirement then it is not recommended to use synchronizer keyword
		
	Internally synchronization concept is implemented by using lock every object in java has a unique lock 
	whenever we are using synchronizer keyword then only lock concept will come into the picture 
	if a thread wants to execute synchronized method on the given object first it has to get lock of that object once thread got the lock then it is allowed to execute any synchronized method on that object
	Once method execution completes automatically thread releases lock 
	Aquiring and releasing lock internally takes care by jvm andd programmer not resposible for this activity
	while a thread executing synchronized method on thr given object the remaining threads are not allowed to execute any synchronized method of same object but the remaining threads are allowed to execute non synchronized methods simulataneously
	
	clas x {
		sync m1();
		sync m2();
		m3();
	}
	
	lock concept is implemented based on object but not on method
	
	JAVA OBJECT : every java object have two areas 1 is synchronized are and other is non synchronized area 
		
		Synchronized : This cab be accessed by only one thread at a time
		
		Non Synchronized : This area can be accessed by any no of threads simulataneously.
	
	Class X {
		Synchronized Area {
			wherever we are performing update opeartion where state of object changes like add delete replace 
		}
		non-synchronized area {
			where we are performing read operation
		}
	}
	
	class ReservationSystem{
	
		checkAvailability(){
			just read operation
		}
		bookTicket(){
			buyticket()
			update operation
		}
	}
	
	
	public class Display {

		public synchronized void wish(String name) {
			for(int i=0;i<5;i++) {
				System.out.print("Happy Birthday : ");
				try {
					Thread.sleep(2000);
				}catch(InterruptedException e) {
					
				}System.out.println(name);
			}
		}
	}
	
	public class MySynchronizedExThread extends Thread{

		Display d;
		String name;
		
		public MySynchronizedExThread(Display d, String name) {
			this.d = d;
			this.name = name;
		}
	
		public void run() {
			d.wish(name);
		}
	}
	
	public class MySynchronizedThreadDemo {
	
		public static void main(String[] args) {
		
		Display d = new Display();
		MySynchronizedExThread t1  =new MySynchronizedExThread(d, "Dhoni");
		MySynchronizedExThread t2  =new MySynchronizedExThread(d, "Raina");
		t1.start();
		t2.start();
		
		}
	}
	
	if we are not declaring wish method as synchronized then both threads will be executed simulataneously hence we will get irregular output
		output	
			Happy Birthday : Dhoni
			Happy Birthday : Raina
			Dhoni

	if we declare wish method as synchronized then at a timr only one thread is allowed to execute on the give display object hence we get regular object
	

**************************************MULTITHREADING END*******************************	
	
02-09-24	
Exception : 
	Default Exception : 
	
	public class DefaultException {

		public static void main(String[] args) {

			doStuff();

		}

		public static void doStuff() {
			doMoreStuff();

		}

		public static void doMoreStuff() {
			System.out.println(10/0);
		}

	}
	
	Output : 
	Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.project.exception.DefaultException.doMoreStuff(DefaultException.java:17)
	at com.project.exception.DefaultException.doStuff(DefaultException.java:12)
	at com.project.exception.DefaultException.main(DefaultException.java:7)


Inside a method if a exception raises then the  method in which exception is raised is responsible to create exception object 

	Exception object has 
		1.Name : java.lang.ArithmeticException
		2.Description : / by zero
		3.StackTrace/Location : at com.project.exception.DefaultException.doMoreStuff(DefaultException.java:17)
		
if exception occurs then jvm checks if this method has handling code if present it is handled else jvm will terminnate this method abnormally without executing remaining code and jvm will remove this entry from runttime stack
Now jvm will check caller method if it handled or not else caller method terminates abnormally

Java Exception Hierarchy
	For all exceptions Throwable class is parent/root exception
	Throwable
		1.Exception : Most of the times exceptions are cause by  our program
		Exceptions are recoverable
			Ex : Read data from remote file locating at London
			If file doesn't contains it throws FileNotFoundException 
			then we can recover by if it is not
			1.RuntimeException
				1.ArithmeticException
				2.NullPointerException
				3.IndexOutofBoundException
					ArrayIOBE
					SIOBE
				4,IllegalArgumentException
					NumberFormatException
			2.IOException
				EndofFileException
				FileNotFoundException
			3.InterruptedException
			
		2.Error : Most of the times errors are not caused by our programs
		Errors are Irrecoverable
		Erros are casued due to lack of system sources
			Ex : OutOfMemoryError, VirtualMachineError
		
			1.VmError
				1.StackOverflowError
				2.OutOfmemoryError
			2.LinkageError

Checked vs Unchecked Exception
	Checked Exception : The Exceptions which are checked by compiler whether programmer handled or not  for smooth execution of program at run time  this execution is called checked exception
		Ex : HallTicketMissingException (Moher cross checks hall ticket before exam)
		Ex : IOException, SQLException, FileNotFoundException, ClassNotFoundException.
	
	UnChecked Exception : Unchecked exceptions are exceptions that are not checked at compile-time, meaning the compiler does not force you to handle or declare them. These are typically exceptions that indicate programming errors or runtime problems.

	Unchecked exceptions are exceptions that are not checked at compile-time, meaning the compiler does not force you to handle or declare them. These are typically exceptions that indicate programming errors or runtime problems.

	Examples: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException, IllegalArgumentException.
	
	Except Child classes of Runtime exception and erros remaining all are Checked Exceptions
	

16.Locking Mechanism
	 locking is a way to control access to shared resources in a program so that only one thread can use a particular resource at a time. This helps prevent issues that can occur when multiple threads try to access or modify the same data simultaneously, 
	 Uses : prevent data corruption and Avoid Conflicts
	 
	 types of locking
	 Synchronized Blocks/Methods:
		Usage: Basic locking provided by Java. You use the synchronized keyword to lock a block of code or an entire method.
		Example:
		java
		Copy code
		synchronized (this) {
			// Code that only one thread can execute at a time
		}
		
	ReentrantLock:

		Usage: More advanced locking with additional features like trying to acquire the lock or waiting for a specific time.
		Example:
		java
		Copy code
		Lock lock = new ReentrantLock();
		lock.lock(); // Acquire the lock
		try {
			// Code that only one thread can execute at a time
		} finally {
			lock.unlock(); // Release the lock
		}
	ReadWriteLock:
		Usage: Allows multiple threads to read data simultaneously but only one thread to write data at a time.
		Example:
		java
		Copy code
		ReadWriteLock rwLock = new ReentrantReadWriteLock();
		Lock readLock = rwLock.readLock();
		Lock writeLock = rwLock.writeLock();

		// Reading
		readLock.lock();
		try {
			// Code for reading
		} finally {
			readLock.unlock();
		}

		// Writing
		writeLock.lock();
		try {
			// Code for writing
		} finally {
			writeLock.unlock();
		}
17.Block &  Synchronized block
	In Java, a normal block and a synchronized block serve different purposes. Here’s a comparison between the two:

	Normal Block
	Purpose: Simply groups statements together. It does not provide any special concurrency control or synchronization features.
	Usage: Regular code execution without any constraints or guarantees about thread safety.
	Example:
	java
	Copy code
	{
		// Normal block of code
		System.out.println("This is a normal block.");
	}
	Synchronized Block
	Purpose: Provides mutual exclusion, ensuring that only one thread can execute a block of code at a time.
	Usage: Used to control access to shared resources and prevent concurrent access issues such as data corruption.
	Example:
	java
	Copy code
	synchronized (this) {
		// Synchronized block of code
		System.out.println("This is a synchronized block.");
		// Critical section of code that only one thread can execute at a time
	}
	
	
	



*****************************JAVA 8 START**************************************
##.Java 8 Features
	Lambda Expressions: Enables functional programming by allowing you to write concise and flexible code.
	Functional Interfaces: Interfaces with a single abstract method, such as Runnable and Callable.
	Stream API: Provides a powerful way to process collections of objects using a functional approach.
	Default Methods: Allows you to add new methods to interfaces without breaking existing implementations.
	Static Method: 
	Optional Class: Helps to handle null values more gracefully and avoid NullPointerException.
	New Date and Time API: Introduces a comprehensive and modern date and time handling API.
	Method References: Provides a way to refer to methods without invoking them, using :: operator.


##.Lambda Expression
	lambda exp is used to implement functional interface in very simple and short manner
	lamda is a anonymous function
	no name no modifier no return type
	syntax : ( ) -> { sop("hello");}

	Benefits:
	Reduce lines of code
	Sequential and Parallel execution by passing behavior as argument in method
	to call api very effectively
	To write more readable,maintanable and concise code
	java compiler understands datatype so here 
	we dont ned to mention type 

1.Optional Class
		optional is a container that can hold a value or it can be empty
		
		Optional class in Java 8 is a container object used to represent the presence or absence of a value. It is a way to avoid NullPointerException and to handle null values more gracefully.
		
		Key Features	
			Avoid Null Checks: 
			Functional Programming: Optional supports functional-style methods like map, flatMap, filter, and ifPresent, making it easier to work with potentially absent values in a more declarative way.
			Default Values: You can provide a default value if the Optional is empty.
				String value = optionalString.orElse("Default Value");
			Avoid NullPointerException: By using Optional, you can avoid the risk of NullPointerException by explicitly handling the absence of a value.
		
		In summary, Optional.of is for non-null values, 
		while Optional.ofNullable is for values that might be null. 
		Ex : 
			Optional<String> optionalNullValue = Optional.ofNullable(nullValue); // Returns Optional.empty


		Ex : 
			Optional<String> optionalString = Optional.ofNullable(getString());

			optionalString.ifPresentOrElse(
				value -> {
					int x = 120;
					System.out.println(value);
				},
				() -> {
					System.out.println("Value is absent");
					int y = 12;
				}
			);
			
		
		Ex: optional using orElse
			String value1 = optionalValue.orElse("Default Value");

		
		Ex: optional using map
			Optional<Integer> length = optionalValue.map(String::length);

		Ex: optional using filter
			 Optional<String> filteredValue = optionalValue.filter(value -> value.startsWith("H"));

		get() can only return a value if wrapped object is not null otherwise throws a no such element exception

		//doing db call
		Employee e = repo.findById(id).get();
		if a value is present it will give output
		else throw no such element found exception to avoid it we use optional

		Optional<Employee> e = repo.findById(id);
		if(e.isPresent()){
			return new ResponseEntity<>(e.get(),HTTPStatus.OK);
		}else{
		 return new ResponseEntity<>("not found",HTTPStatus.NOT_FOUND);
		}



		Optional<String> optionalValue = Optional.of("Hello, World!");

		optionalValue.ifPresentOrElse("name is present","name not present")
					

15.Java 8 DateTime APi
	The new API is located in the java.time package and is designed to be immutable and thread-safe
	Java 8 introduced a new Date and Time API that significantly improves the handling of date and time operations compared to the old java.util.Date and java.util.Calendar classes.
	
	Key Classes in the Java 8 Date-Time API
		
	LocalDate:
		Represents a date without time (e.g., 2024-08-08).
		Example:
		java
		Copy code
		LocalDate today = LocalDate.now();
		LocalDate birthday = LocalDate.of(1990, 8, 8);
	LocalTime:
		Represents a time without a date (e.g., 15:30:00).
		Example:
		java
		Copy code
		LocalTime now = LocalTime.now();
		LocalTime meetingTime = LocalTime.of(14, 30);
	LocalDateTime:
		Represents a date and time without a time zone (e.g., 2024-08-08T15:30:00).
		Example:
		java
		Copy code
		LocalDateTime dateTimeNow = LocalDateTime.now();
		LocalDateTime specificDateTime = LocalDateTime.of(2024, 8, 8, 15, 30);
	ZonedDateTime:
		Represents a date and time with a time zone (e.g., 2024-08-08T15:30:00+01:00[Europe/Paris]).
		Example:
		java
		Copy code
		ZonedDateTime zonedDateTimeNow = ZonedDateTime.now();
		ZonedDateTime specificZonedDateTime = ZonedDateTime.of(2024, 8, 8, 15, 30, 0, 0, ZoneId.of("Europe/Paris"));
	DateTimeFormatter:
		Used to format and parse date-time objects.
		Example:
		java
		Copy code
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		String formattedDate = LocalDateTime.now().format(formatter);
		LocalDateTime parsedDate = LocalDateTime.parse("2024-08-08 15:30:00", formatter);
		
// format string to date
		// Original date string
        String originalDateStr = "2024-08-08";  // Example format: yyyy-MM-dd
        
        // Define the original format of the date string
        DateTimeFormatter originalFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        
        // Define the desired format
        DateTimeFormatter targetFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        
        try {
            // Parse the original date string to a LocalDate
            LocalDate date = LocalDate.parse(originalDateStr, originalFormatter);
            
            // Format the LocalDate to the target format
            String formattedDateStr = date.format(targetFormatter);
            
            // Output the formatted date
            System.out.println("Formatted Date: " + formattedDateStr);
        } catch (DateTimeParseException e) {
            System.err.println("Invalid date format: " + e.getMessage());
        }

	Date&Time API

	LocalDateTime dt = LocalDateTime.now();
	int dd = dt.getDayOfMonth();
	String month = dt.getMonth().toString();
	int mm = dt.getMonthValue();
	int year = dt.getYear();
	
	int h = dt.getHour();
	int m = dt.getMinute();
	int s = dt.getSecond();
	int n = dt.getNano();
	
	System.out.printf("\nDate : %d - %s - %d - %d\n",dd,month,mm,year);
	System.out.println(dt);
	System.out.printf("Date : %d - %s - %d - %d",dd,month,mm,year);
	System.out.printf("\nTime : %d - %d - %d - %d",h,m,s,n);
	
	LocalDateTime dob = LocalDateTime.of(2000, 4, 21, 6,21,8);
	System.out.println("\nDOB : "+dob);
	System.out.println("Before 4 months : "+dob.minusMonths(4));
	System.out.println("After 4 Months : "+dob.plusMonths(4));
	
	LocalDate dateOfBirth = LocalDate.of(2000, 4, 21);
	LocalDate today = LocalDate.now();
	Period p = Period.between(dateOfBirth, today);
	System.out.printf("\nyour age is %d years %d months %d days",p.getYears(), p.getMonths(), p.getDays());

	LocalDate buyCarDate = LocalDate.of(2030,04, 21);
	Period timePeriod = Period.between(today, buyCarDate);
	int daysLeftForCar = timePeriod.getYears()*365 + timePeriod.getMonths()*30 + timePeriod.getDays();
	System.out.printf("\nDays left to buy new car %d\n",daysLeftForCar);

	//find leap year or not
	Year yr = Year.of(2024);
	System.out.println(yr.isLeap()?"Leap Year ":"Not a leap year ");
	System.out.println(yr);
	
//		DateTimeFormatter formatter = DateTimeFormatter.
	LocalDateTime beforeFormat = LocalDateTime.now();
	System.out.println("Before formatting "+beforeFormat);
	
	DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern("dd-MM-YYYY HH:mm:ss");
	
	String afterFormat = beforeFormat.format(dateFormat);
	System.out.println("After formatting "+afterFormat);
	
	Date : 18 - AUGUST - 8 - 2024
	2024-08-18T14:27:15.275062200
	Date : 18 - AUGUST - 8 - 2024
	Time : 14 - 27 - 15 - 275062200
	DOB : 2000-04-21T06:21:08
	Before 4 months : 1999-12-21T06:21:08
	After 4 Months : 2000-08-21T06:21:08

	your age is 24 years 3 months 28 days
	Days left to buy new car 2068
	Leap Year 
	2024
	Before formatting 2024-08-18T14:27:15.296007300
	After formatting 18-08-2024 14:27:15

Drawbacks of previous datetime api
		1. Easily Changeable Dates (Date and Calendar Classes)
		Problem: The old Date and Calendar classes could be changed after they were created. This could lead to mistakes, especially when multiple parts of a program try to use the same date at the same time.
		2. Confusing and Error-Prone Date Class
		Problem: The Date class was confusing to use. For example, months were numbered starting from 0 (January is 0, February is 1, etc.), which often caused errors.
		3. Complicated Calendar Class
		Problem: The Calendar class was introduced to fix some problems with Date, but it was complicated and hard to use correctly. It was easy to make mistakes when working with dates.
		4. Not Safe to Use SimpleDateFormat with Multiple Threads
		Problem: SimpleDateFormat, used for formatting and parsing dates, was not safe to use in programs that run multiple tasks at the same time. This could cause incorrect date values to appear.
		5. Difficult Time Zone Handling
		Problem: Working with different time zones was difficult and error-prone with the old classes. The Date class didn't even store time zone information.
		6. Limited Formatting and Parsing Options
		Problem: Formatting dates into strings or parsing strings into dates was limited and often required extra work to get right.
		7. Hard to Do Date Calculations
		Problem: Simple tasks like adding days or months to a date were complicated and could easily go wrong.

##.Thread pool used by parallel streams /Fork-join pool in thread pools 
	When you use parallel streams in Java, the framework uses a common fork-join pool to manage the threads. This pool is an instance of ForkJoinPool and is shared among all parallel streams in the application.

	Key Points about the Fork-Join Pool
	Default Pool: By default, the parallel stream operations use the common fork-join pool, which is created with a number of threads equal to the number of available processors (as returned by Runtime.getRuntime().availableProcessors()).

	Custom Pool: You can also provide a custom fork-join pool if you need more control over the parallelism. This can be done using the ForkJoinPool class and the submit method.

	Example: Using the Default Fork-Join Pool
	Here's a simple example of using parallel streams with the default fork-join pool:

	import java.util.Arrays;
	import java.util.List;

	public class ParallelStreamExample {
		public static void main(String[] args) {
			List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

			int sum = numbers.parallelStream()
							 .mapToInt(Integer::intValue)
							 .sum();

			System.out.println("Sum: " + sum);
		}
	}
	Example: Using a Custom Fork-Join Pool
	If you want to use a custom fork-join pool, you can do so like this:

	import java.util.Arrays;
	import java.util.List;
	import java.util.concurrent.ForkJoinPool;

	public class CustomForkJoinPoolExample {
		public static void main(String[] args) {
			List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

			ForkJoinPool customThreadPool = new ForkJoinPool(4); // Custom pool with 4 threads

			int sum = customThreadPool.submit(() ->
				numbers.parallelStream()
					   .mapToInt(Integer::intValue)
					   .sum()
			).join();

			System.out.println("Sum: " + sum);
		}
	}
	Summary
	Default Fork-Join Pool: Used by default for parallel streams, with a size equal to the number of available processors.
	Custom Fork-Join Pool: Can be specified if you need more control over the parallelism.
*****************************JAVA 8 END****************************************



*****************************SPRING BOOT START*********************************
##diffrenet steps you follow when you get requiremet
	Let's say the requirement is to develop a new feature for an e-commerce application that allows users to track their orders:
	Requirement Gathering: Meet with the product owner to understand the tracking feature requirements.
	Analysis and Planning: Analyze the feasibility, define the scope, and create a project plan.
	Design: Design the system architecture and user interface for the tracking feature.
	Development: Set up the environment, write the code for the tracking feature, and perform unit testing.
	Testing: Conduct integration testing, system testing, and UAT.
	Deployment: Prepare deployment scripts, deploy the feature to production, and monitor for issues.
	Maintenance: Fix any bugs and implement enhancements based on user feedback.


##.What is Dependency Injection and explain its types
	Constructor Injection
		Definition: Dependencies are provided through the constructor of the class.
		Usage:
			Mandatory Dependencies: Suitable for Mandatory Dependencies. Ensures that all required dependencies are provided at the time of object creation.
			Immutability: Promotes immutability by making the dependencies final.
			Thread Safety: Generally safer in multi-threaded environments as dependencies are set only once.
		Ex:
			@Component
			public class OrderService {

				private final PaymentService paymentService;

				@Autowired
				public OrderService(PaymentService paymentService) {
					this.paymentService = paymentService;
				}
			}
			
	Setter Injection
		Definition: Dependencies are provided through setter methods after the object is created.
		Usage:
			Optional Dependencies: Suitable for optional dependencies that may not always be required.
			Flexibility: Allows changing dependencies after object creation.
			Readability: Can make the code more readable by separating the dependency injection from object creation.
		Ex:
			@Component
			public class NotificationService {

				private EmailService emailService;

				@Autowired(required = false)
				public void setEmailService(EmailService emailService) {
					this.emailService = emailService;
				}
			}
	Field Injection
		Definition: Dependencies are injected directly into the fields of a class using the @Autowired annotation.
		Usage:
			Simplicity: Easy to use and requires minimal code.
			Visibility: Dependencies are not visible in the constructor or setter methods, which can make the code less readable.
		Example:
			@Component
			public class MyService {
				@Autowired
				private MyRepository repository;
			}

##.Exception handling in SB

	@RestControllerAdvice
	public class GlobalExceptionHandler {

		@ExceptionHandler(ResourceNotFoundException.class)
		public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
			ErrorResponse errorResponse = new ErrorResponse(ex.getMessage(), HttpStatus.NOT_FOUND.value());
			return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
		}

		@ExceptionHandler(Exception.class)
		public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
			ErrorResponse errorResponse = new ErrorResponse(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR.value());
			return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
	
	public class ResourceNotFoundException extends RuntimeException {
		public ResourceNotFoundException(String message) {
			super(message);
		}
	}
	
	@RestController
	public class UserController {

		@GetMapping("/users/{id}")
		public User getUserById(@PathVariable Long id) {
			// Simulate a user not found scenario
			if (id == 1) {
				throw new ResourceNotFoundException("User not found with id: " + id);
			}
			return new User(id, "John Doe");
		}
	}

3.Spring frameworks(IOC, AOP, MVC, Boot) : Main usage & differences

	### **Spring IoC (Inversion of Control)**
	**Main Usage**:
	- **Dependency Injection**: Manages the dependencies between objects, promoting loose coupling and easier testing.
	- **Configuration Management**: Uses XML or annotations to configure beans and their dependencies.
	- **Lifecycle Management**: Manages the lifecycle of beans, including initialization and destruction.

	**Example**:
	```java
	@Component
	public class MyService {
		private final MyRepository repository;

		@Autowired
		public MyService(MyRepository repository) {
			this.repository = repository;
		}
	}
	```

	### **Spring AOP (Aspect-Oriented Programming)**
	**Main Usage**:
	- **Cross-Cutting Concerns**: Separates concerns like logging, security, and transaction management from business logic.
	- **Modularity**: Allows adding behavior to existing code without modifying it.
	- **Declarative Services**: Provides declarative transaction management and other services.

	**Example**:
	```java
	@Aspect
	@Component
	public class LoggingAspect {
		@Before("execution(* com.example.service.*.*(..))")
		public void logBefore(JoinPoint joinPoint) {
			System.out.println("Executing: " + joinPoint.getSignature().getName());
		}
	}
	```

	### **Spring MVC (Model-View-Controller)**
	**Main Usage**:
	- **Web Applications**: Builds web applications using the MVC pattern.
	- **Request Handling**: Uses `DispatcherServlet` to route requests to appropriate controllers.
	- **View Rendering**: Supports various view technologies like JSP, Thymeleaf, and FreeMarker.

	**Example**:
	```java
	@Controller
	public class MyController {
		@GetMapping("/hello")
		public String hello(Model model) {
			model.addAttribute("message", "Hello, World!");
			return "hello";
		}
	}
	```

	### **Spring Boot**
	**Main Usage**:
	- **Rapid Development**: Simplifies the setup and development of Spring applications.
	- **Auto-Configuration**: Automatically configures Spring components based on the classpath.
	- **Embedded Servers**: Provides embedded servers like Tomcat and Jetty for easy deployment.

	**Example**:
	```java
	@SpringBootApplication
	public class MyApplication {
		public static void main(String[] args) {
			SpringApplication.run(MyApplication.class, args);
		}
	}
	```

	### **Key Differences**
	- **Spring IoC**: Focuses on dependency injection and managing the lifecycle of beans.
	- **Spring AOP**: Deals with cross-cutting concerns and modularizing aspects of the application.
	- **Spring MVC**: Provides a framework for building web applications using the MVC pattern.
	- **Spring Boot**: Simplifies Spring application development with auto-configuration and embedded servers.

## 	Difference between Spring MVC & Boot
	Spring MVC
		Purpose: A framework for building web applications using the Model-View-Controller (MVC) design pattern.
		Configuration: Requires manual configuration of components like view resolvers, data sources, and other beans.
		Setup: Involves setting up a web.xml file or using Java-based configuration to define the DispatcherServlet and other components.
		Flexibility: Provides fine-grained control over the configuration and setup of the application.
		Usage: Ideal for developers who need detailed control over their web application setup and configuration.
	Spring Boot
		Purpose: A framework that simplifies the development of Spring applications by providing auto-configuration and embedded servers.
		Configuration: Automatically configures Spring components based on the classpath and properties. Minimal manual configuration is needed.
		Setup: No need for web.xml or complex configuration files. Uses annotations like @SpringBootApplication to bootstrap the application.
		Embedded Servers: Comes with embedded servers like Tomcat, Jetty, and Undertow, making it easy to run applications without external server setup.
		Usage: Ideal for rapid application development and deployment. Suitable for microservices and standalone applications.
	Key Differences
		Configuration: Spring MVC requires manual configuration, while Spring Boot provides auto-configuration.
		Setup: Spring MVC involves more setup steps, whereas Spring Boot simplifies setup with annotations and embedded servers.
		Flexibility vs. Convenience: Spring MVC offers more flexibility and control, while Spring Boot focuses on convenience and rapid development.
		Embedded Servers: Spring Boot includes embedded servers, whereas Spring MVC typically requires an external server setup.
		Example Usage

##.What are Springboot Starter dependencies 
	spring-boot-starter-web:
	spring-boot-starter-data-jpa:
	spring-boot-starter-security:
	spring-boot-starter-test: 

##.Here are some ways to optimize performance in Spring Boot projects:

	1. Caching
		Implementing caching mechanisms (e.g., using Ehcache, Redis).
	2. Database Optimization
		Using pagination for queries.
		Optimizing SQL queries and using proper indexing.
	3. Asynchronous Processing
		Utilizing @Async for long-running tasks.
	4. Connection Pooling
		Configuring connection pools (e.g., HikariCP) for database connections.
	5. Profiling and Monitoring
		Using tools like Spring Boot Actuator and APM solutions.
	6. Load Balancing
		Implementing load balancing for distributed systems.
	7. Reducing Startup Time
		Using Spring Boot's lazy initialization feature.

8.What is JWT token ?
	JWTs are a versatile tool for authentication, authorization, and information exchange
	A JWT is composed of three parts, each encoded in Base64Url format and separated by dots (.)
	Header:
		Contains metadata about the token, including the type of token (JWT) and the signing algorithm used (e.g., HMAC SHA256, RSA).
		Example:
		json
		Copy code
		{
		  "alg": "HS256",
		  "typ": "JWT"
		}
	Payload:
		Contains the claims or statements about an entity (typically, the user) and additional metadata. Claims can be categorized into:
		Registered Claims: Standard claims like iss (issuer), exp (expiration time), sub (subject), and aud (audience).
		Public Claims: Custom claims agreed upon by multiple parties.
		Private Claims: Custom claims used only within a specific application or system.
		Example:
		json
		Copy code
		{
		  "sub": "1234567890",
		  "name": "John Doe",
		  "iat": 1516239022
		}
	Signature:
		Used to verify the authenticity of the token and ensure that it has not been tampered with. The signature is created by taking the encoded header and payload, combining them with a secret key or private key (for asymmetric algorithms), and applying the specified signing algorithm.
		Example using HMAC SHA256:
		scss
		Copy code
		HMACSHA256(
		  base64UrlEncode(header) + "." +
		  base64UrlEncode(payload),
		  secret)
	Example JWT
	A JWT might look like this:
		eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYMTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
		
9.What is authentication & Autherization ? 
	Authentication is the process of verifying the identity of a user.
	Authorization is the process of determining whether a user has permission to access a resource or perform a specific action
	
10.Springboot Profiles
	In Spring Boot, profiles are a way to define and manage different configurations for different environments 
		@Configuration
		@Profile("dev")
		public class DevConfig {
			// Beans and settings specific to the 'dev' profile
		}

		@Configuration
		@Profile("prod")
		public class ProdConfig {
			// Beans and settings specific to the 'prod' profile
		}

	# application.properties
	spring.profiles.active=dev

11.if we have application.properties & application-dev.properties which is read
	Without Explicit Profile: Only application.properties is used.
	With Explicit Profile (e.g., dev): Both application.properties and application-dev.properties are loaded. Properties in application-dev.properties override those in application.properties
	
12.How to handle circular dependency in spring boot	
	Circular dependencies occur when two or more beans depend on each other, creating a cycle that can lead to issues during bean initialization.
	
	@Lazy Annotation: Delays bean initialization to break the cycle.
		@Component
		public class BeanA {
			private final BeanB beanB;

			@Autowired
			public BeanA(@Lazy BeanB beanB) {
				this.beanB = beanB;
			}
		}

		@Component
		public class BeanB {
			private final BeanA beanA;

			@Autowired
			public BeanB(BeanA beanA) {
				this.beanA = beanA;
			}
		}
	Setter Injection: Allows Spring to create beans first and then inject dependencies.
	Field Injection: Similar to setter injection, allows Spring to inject dependencies after bean creation.

##.Maven CLean & install
mvn clean
	Purpose: The clean command is used to remove the target directory, which contains all the compiled classes, JAR files, and other build artifacts from previous builds.
	Usage: It ensures that the next build starts from a clean state without any leftover files from previous builds.
	Command: mvn clean
mvn install
	Purpose: The install command compiles the code, runs tests, and packages the project into a JAR or WAR file. It then installs the packaged artifact into the local Maven repository.
	Usage: This command is used to build the project and make the artifact available for other projects on the same machine.
	Command: mvn install

*****************************SPRING BOOT END***********************************


*****************************REST API START************************************
1.Difference between @PathParam & @QueryParam
	@PathVariable / @PathParam: Binds a method parameter to a URI variable.
	@RequestParam / @QueryParam: Binds a method parameter to a query parameter 
	
	@PathVariable / @PathParam: Extracts values from the URI path.
	@RequestParam / @QueryParam: Extracts values from the query string.

	@PathVariable / @PathParam: Typically used for mandatory parameters that identify specific resources.
	@RequestParam / @QueryParam: Typically used for optional parameters that filter or modify the
		
	@PathVariable / @PathParam: https://example.com/users/123
	@RequestParam / @QueryParam: https://example.com/search?lang=java&fram=spring

2.Rest Endponits
	HTTP status codes are used in REST APIs to indicate the result of a client’s request. They provide information about the success or failure of the request 
		200 OK: Used for successful GET and PUT requests.
		201 Created: Used when creating a new resource with POST.
		204 No Content: Used for successful DELETE requests or PUT requests that don’t return any data.
		400 Bad Request: Used when the client sends invalid data or parameters.
		401 Unauthorized: Used when authentication is required but not provided or is invalid.
		403 Forbidden: Used when the client does not have permission to access the resource.
		404 Not Found: Used when the requested resource cannot be found.
		500 Internal Server Error: Used when the server encounters an unexpected condition.

3.Rest Api Operations
	1. GET
		Purpose: Retrieve information from the server.
		Request: No body required. URL specifies the resource to fetch.
		Example: GET /users/123 retrieves information about user with ID 123.
		Idempotency: Idempotent (multiple requests have the same result).
	2. POST
		Purpose: Create a new resource on the server or submit data to be processed.
		Request: Contains the data to be created or processed in the request body.
		Example: POST /users with data { "name": "John Doe", "email": "john.doe@example.com" } creates a new user.
		Idempotency: Non-idempotent (multiple requests can result in multiple resources).
	3. PUT
		Purpose: Update or replace an existing resource.
		Request: Contains the complete data for the resource to be updated or replaced.
		Example: PUT /users/123 with data { "name": "John Doe", "email": "john.doe@newdomain.com" } updates user 123.
		Idempotency: Idempotent (repeated requests have the same result).
	4. PATCH
		Purpose: Partially update an existing resource.
		Request: Contains only the fields that need to be updated.
		Example: PATCH /users/123 with data { "email": "john.doe@newdomain.com" } updates only the email of user 123.
		Idempotency: Generally idempotent, but not always guaranteed.
	5. DELETE
		Purpose: Remove a resource from the server.
		Request: No body required. URL specifies the resource to delete.
		Example: DELETE /users/123 deletes the user with ID 123.
		Idempotency: Idempotent (multiple requests have the same effect).
	6. OPTIONS
		Purpose: Retrieve the allowed HTTP methods and other options for a resource.
		Request: No body required. URL specifies the resource.
		Example: OPTIONS /users/123 returns methods like GET, POST, PUT, etc., allowed for user 123.
		Idempotency: Idempotent.
	7. HEAD
		Purpose: Retrieve the headers of a resource, without the body.
		Request: No body required. URL specifies the resource.
		Example: HEAD /users/123 retrieves the headers of the resource for user 123.
		Idempotency: Idempotent.
		

4.Here are some best practices for securing REST APIs:
	1. Authentication
		Use strong authentication mechanisms (e.g., OAuth2, JWT).
	2. Authorization
		Implement role-based access control (RBAC) to restrict access to resources.
	3. HTTPS
		Always use HTTPS to encrypt data in transit.
	4. Input Validation
		Validate and sanitize all inputs to prevent injection attacks.
	5. Rate Limiting
		Implement rate limiting to mitigate DDoS attacks.
	6. Logging and Monitoring
		Log access and error events for monitoring and auditing.
	7. CORS Configuration
		Properly configure Cross-Origin Resource Sharing (CORS) to control access from different domains.
	8. Use Security Headers
		Implement security headers (e.g., Content Security Policy, X-Content-Type-Options).
	9. Token Expiration and Revocation
		Use short-lived tokens and provide a mechanism for revocation.
	10. API Gateway
		Utilize an API gateway for centralized security management and traffic control.
	11. Versioning
		Version your APIs to manage changes without breaking existing clients.
	12. Security Testing
		Regularly perform security testing, including penetration testing and vulnerability scanning.


5.key standards and best practices to follow to develop an api
	1. Use the Right HTTP Methods
		GET: Retrieve data.
		POST: Create new resources.
		PUT: Update existing resources.
		DELETE: Remove resources.
	2. Return Appropriate Status Codes
		200 OK: Successful GET, PUT, DELETE.
		201 Created: Successful POST.
		204 No Content: Successful DELETE with no response body.
		400 Bad Request: Invalid request parameters.
		404 Not Found: Resource not found.
		500 Internal Server Error: Server-side error.
	3. Use Meaningful Resource Names
		Use nouns for resource names (e.g., /users, /orders).
		Avoid using verbs in URIs (e.g., /getUser).
	4. Version Your API
		Include versioning in your API URIs (e.g., /api/v1/users).
		This helps manage changes and backward compatibility.
	5. Document Your API
		Use tools like Swagger or Springdoc OpenAPI to generate interactive API documentation.
		Ensure your API documentation is up-to-date and comprehensive.
	6. Validate Input
		Use annotations like @Valid and @NotNull to validate request parameters and payloads.
		Return meaningful error messages for invalid inputs.
	7. Handle Exceptions Gracefully
		Implement global exception handling using @RestControllerAdvice and @ExceptionHandler.
		Return consistent error responses with appropriate status codes.
	8. Secure Your API
		Use HTTPS to encrypt data in transit.
		Implement authentication and authorization using Spring Security.
		Protect against common vulnerabilities like SQL injection and cross-site scripting (XSS).
	9. Optimize Performance
		Use pagination and filtering to handle large datasets.
		Implement caching to reduce load on the server.
		Monitor and profile your API to identify and resolve performance bottlenecks.
	10. Test Your API
		Write unit tests for your service and controller layers.
		Use tools like Postman or REST Assured for integration testing.
		Ensure your tests cover various scenarios and edge cases.

*****************************REST API END**************************************


*****************************MICROSERVICES START************************************

*****************************MICROSERVICES END**************************************

*****************************JPA HIBERNATE START************************************


Java Persistence API (JPA) is a specification in Java that provides a standard for object-relational mapping (ORM) and data management in Java applications. It simplifies the interaction between Java applications and relational databases by allowing developers to work with Java objects and classes rather than dealing with database-specific SQL queries directly.

JPA: A specification for ORM in Java, providing a standard way to interact with relational databases using Java objects. It is designed to be implemented by various frameworks.

Hibernate: A popular ORM framework that implements JPA and offers additional features and optimizations beyond the JPA specification.

public interface PersonRepository extends JpaRepository<Person, Long> {
   
   @Query("SELECT p FROM Person p WHERE p.name = :name")
    List<Person> findByName(@Param("name") String name);
}

// configure multiple databases using jpa

@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.primary.repository",
    entityManagerFactoryRef = "primaryEntityManagerFactory",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {

    @Bean(name = "primaryDataSource")
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/primarydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }

    @Bean(name = "primaryEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);
        emf.setPackagesToScan("com.example.primary.model");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        return emf;
    }

    @Bean(name = "primaryTransactionManager")
    public PlatformTransactionManager transactionManager(
            @Qualifier("primaryEntityManagerFactory") LocalContainerEntityManagerFactoryBean entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory.getObject());
        return transactionManager;
    }
}

*****************************JPA HIBERNATE END************************************



*****************************SQL START************************************

TODO: 
	find second highest element in table
	how to use group by 
	

3. What are the main types of SQL commands?
	DDL (Data Definition Language): CREATE, ALTER, DROP, TRUNCATE.
	DML (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE.
	DCL (Data Control Language): GRANT, REVOKE.
	TCL (Transaction Control Language): COMMIT, ROLLBACK, SAVEPOINT.

What is a primary key?
	A primary key is a unique identifier for each record in a table. It ensures that no two rows have the same value in the primary key column(s), and it does not allow NULL values.

What is a foreign key?
	A foreign key is a column (or set of columns) in one table that refers to the primary key in another table. It establishes and enforces a relationship between the two tables, ensuring data integrity.
	
What is normalization in databases?
	Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. This involves dividing large tables into smaller, related tables and defining relationships between them to ensure consistency and avoid anomalies.

What are the different operators available in SQL?
	Arithmetic Operators: +, -, *, /, %
	Comparison Operators: =, !=, <>, >, <, >=, <=
	Logical Operators: AND, OR, NOT
	Set Operators: UNION, INTERSECT, EXCEPT
	Special Operators: BETWEEN, IN, LIKE, IS NULL
	
What is a view in SQL?
	A view is a virtual table created by a SELECT query. It does not store data itself, but presents data from one or more tables in a structured way. Views simplify complex queries, improve readability, and enhance security by restricting access to specific rows or columns.	

What are the different types of joins in SQL?
	INNER JOIN: Returns rows that have matching values in both tables.
	LEFT JOIN (LEFT OUTER JOIN): Returns all rows from the left table, and matching rows from the right table.
	RIGHT JOIN (RIGHT OUTER JOIN): Returns all rows from the right table, and matching rows from the left table.
	FULL JOIN (FULL OUTER JOIN): Returns all rows when there is a match in either table.
	CROSS JOIN: Produces the Cartesian product of two tables.

What is the purpose of the GROUP BY clause?
	The GROUP BY clause is used to arrange identical data into groups. It is typically used with aggregate functions (such as COUNT, SUM, AVG) to perform calculations on each group rather than on the entire dataset.

What are aggregate functions in SQL?
	Aggregate functions perform calculations on a set of values and return a single value. Common aggregate functions include:

	COUNT(): Returns the number of rows.
	SUM(): Returns the total sum of values.
	AVG(): Returns the average of values.
	MIN(): Returns the smallest value.
	MAX(): Returns the largest value.
	
What is the difference between the WHERE and HAVING clauses?
	WHERE: Filters rows before any grouping takes place.
	HAVING: Filters grouped data after the GROUP BY clause has been applied.
	In short, WHERE applies to individual rows, while HAVING applies to groups.
	
What are indexes, and why are they used?
	index is typically created on one or more columns of a table. 
	It works like a book's index, where you can quickly find the page number of a topic instead of reading the entire book.
	Not every column should be indexed. Indexes are most beneficial on columns that are frequently used in WHERE clauses, joins, and sorting operations.
	Indexes are database objects that improve query performance by allowing faster retrieval of rows. 
	
	Example: 
		CREATE INDEX idx_employee_id ON employee(employee_id);


What is the difference between DELETE and TRUNCATE commands?
	DELETE: Removes rows one at a time and records each deletion in the transaction log, allowing rollback. It can have a WHERE clause.
	TRUNCATE: Removes all rows at once without logging individual row deletions. It cannot have a WHERE clause and is faster than DELETE for large data sets.	
	
What is the purpose of the SQL ORDER BY clause?
	The ORDER BY clause sorts the result set of a query in either ascending (default) or descending order, based on one or more columns. This helps present the data in a more meaningful or readable sequence.	
	
What are the differences between SQL and NoSQL databases?
	SQL Databases:
		Use structured tables with rows and columns.
		Rely on a fixed schema.
		Offer ACID properties.
	NoSQL Databases:
		Use flexible, schema-less structures (e.g., key-value pairs, document stores).
		Are designed for horizontal scaling.
		Often focus on performance and scalability over strict consistency.

What are the types of constraints in SQL?
	NOT NULL: Ensures a column cannot have NULL values.
	UNIQUE: Ensures all values in a column are distinct.
	PRIMARY KEY: Uniquely identifies each row in a table.
	FOREIGN KEY: Ensures referential integrity by linking to a primary key in another table.
	CHECK: Ensures that all values in a column satisfy a specific condition.
	DEFAULT: Sets a default value for a column when no value is specified.

Drop Truncate Delete	
	DROP: Removes the entire table and its data.
	TRUNCATE: Removes all data but keeps the table structure.
	DELETE: Removes specific rows based on a condition.
	
What is a stored procedure?
	A stored procedure is a precompiled set of SQL statements stored in the database. It can take input parameters, perform logic and queries, and return output values or result sets. Stored procedures improve performance and maintainability by centralizing business logic.

What is a UNION operation, and how is it used?
	The UNION operator combines the result sets of two or more SELECT queries into a single result set, removing duplicate rows. This is useful when we need a consolidated view of data from multiple tables or queries that have similar structure.

	Example:
		SELECT Name FROM Customers  
		UNION  
		SELECT Name FROM Employees;


Find third highest salaryusing sql
	SELECT DISTINCT salary
	FROM employees
	ORDER BY salary DESC
	LIMIT 1 OFFSET 2;


*****************************SQL END**************************************